# 跨平台自定义标题栏实现方案

## 概述

本项目实现了一个跨平台的自定义标题栏方案，**所有平台都移除了系统原生的标题栏**，在不同操作系统上提供了统一且符合各平台设计规范的用户体验：

- **macOS**: 移除标题栏，但保留系统红黄绿按钮（浮动在内容之上），内容可延伸到顶部区域
- **Windows/Linux**: 完全移除系统装饰（包括标题栏和窗口边框），完全自定义实现

## 架构设计

### 整体布局结构

```
┌─────────────────────────────────────────────────────┐
│[macOS系统按钮]│           标题           [Win按钮]     │ ← 35px 高度标题栏  │                                      │
├              ┬──────────────────────────────────────┤
│              │                                      │
│   侧边栏      │          主内容区域                    │
│   230px      │                                      │
│              │                                      │
│   [Logo]     │                                      │
│              │                                      │
│   [菜单]      │                                      │
│              │                                      │
│              │                                      │
└──────────────┴──────────────────────────────────────┘
```

## 技术实现

### 1. Rust 后端窗口配置

**文件位置**: [src-tauri/src/window.rs:94-103](src-tauri/src/window.rs#L94-L103)

使用条件编译根据不同操作系统设置窗口属性：

```rust
// 创建窗口的核心代码
fn build_window(label: &str, title: &str) -> (Window, bool) {
    let mut builder = tauri::WindowBuilder::new(
        app_handle,
        label,
        tauri::WindowUrl::App("index.html".into()),
    )
    .additional_browser_args("--disable-web-security")
    .focused(true)
    .title(title)
    .visible(false);

    #[cfg(target_os = "macos")]
    {
        builder = builder
            .title_bar_style(tauri::TitleBarStyle::Overlay)
            .hidden_title(true);
    }

    #[cfg(not(target_os = "macos"))]
    {
        builder = builder
            .transparent(true)
            .decorations(false);
    }

    let window = builder.build().unwrap();

    // 为非 Linux 系统添加窗口阴影
    if label != "screenshot" {
        #[cfg(not(target_os = "linux"))]
        set_shadow(&window, true).unwrap_or_default();
    }

    (window, false)
}
```

**关键配置说明**:

#### macOS 配置

```rust
.title_bar_style(tauri::TitleBarStyle::Overlay)
.hidden_title(true)
```

- `TitleBarStyle::Overlay`: **移除标题栏**，允许内容延伸到窗口顶部区域，但系统红黄绿按钮会浮动显示在内容之上
- `hidden_title(true)`: 隐藏默认的窗口标题文字

**关键理解**: 这个模式不是"保留标题栏"，而是"让内容覆盖到标题栏位置"，只是系统按钮会自动浮动在最上层

#### Windows/Linux 配置

```rust
.transparent(true)
.decorations(false)
```

- `transparent(true)`: 启用窗口透明度，允许自定义背景
- `decorations(false)`: 完全移除系统原生的标题栏和边框

### 2. 前端布局实现

**文件位置**: [src/window/Config/index.jsx](src/window/Config/index.jsx)

#### 左侧边栏结构

```jsx
<Card
  shadow="none"
  className={`${transparent ? 'bg-background/90' : 'bg-content1'} float-left h-screen w-[230px] rounded-none ${
    osType === 'Linux' && 'rounded-l-[10px] border-1'
  } cursor-default select-none border-r-1 border-default-100`}
>
  {/* 顶部拖拽区域 - macOS 系统按钮占位 */}
  <div className="h-[35px] p-[5px]">
    <div className="h-full w-full" data-tauri-drag-region="true" />
  </div>

  {/* Logo 区域 */}
  <div className="p-[5px]">
    <div data-tauri-drag-region="true">
      <img alt="pot logo" src="icon.svg" className="m-auto mb-[30px] h-[60px] w-[60px]" draggable={false} />
    </div>
  </div>

  {/* 侧边栏导航菜单 */}
  <SideBar />
</Card>
```

**设计要点**:

- 固定宽度 230px
- 顶部 35px 高度预留给标题栏（macOS 为系统按钮留出空间）
- 使用 `data-tauri-drag-region='true'` 使区域可拖拽窗口
- Logo 区域也可拖拽，提升用户体验

#### 右侧内容区域结构

```jsx
<div
  className={`ml-[230px] h-screen cursor-default select-none bg-background ${
    osType === 'Linux' && 'rounded-r-[10px] border-1 border-l-0 border-default-100'
  }`}
>
  {/* 标题栏拖拽区域 - fixed 定位覆盖整个标题栏 */}
  <div data-tauri-drag-region="true" className="fixed left-[235px] right-[5px] top-[5px] h-[30px]" />

  {/* 可见的标题栏 */}
  <div className="flex h-[35px] justify-between">
    {/* 左侧标题 */}
    <div className="flex">
      <h2 className="m-auto ml-[10px]">{t(`config.${location.pathname.slice(1)}.title`)}</h2>
    </div>

    {/* 右侧窗口控制按钮 - 仅非 macOS 显示 */}
    <div className="flex">{osType !== 'Darwin' && <WindowControl />}</div>
  </div>

  <Divider />

  {/* 主内容区域 */}
  <div className={`overflow-y-auto p-[10px] ${osType === 'Linux' ? 'h-[calc(100vh-38px)]' : 'h-[calc(100vh-36px)]'}`}>
    {page}
  </div>
</div>
```

**设计要点**:

- 左边距 230px，为侧边栏留出空间
- 使用 `fixed` 定位的拖拽区域覆盖整个标题栏
- 条件渲染：只在非 macOS 系统显示自定义窗口控制按钮
- 根据操作系统调整内容区域高度

### 3. 自定义窗口控制组件

**文件位置**: [src/components/WindowControl/index.jsx](src/components/WindowControl/index.jsx)

```jsx
import { VscChromeClose, VscChromeMinimize, VscChromeMaximize, VscChromeRestore } from 'react-icons/vsc'
import React, { useEffect, useState } from 'react'
import { appWindow } from '@tauri-apps/api/window'
import { listen } from '@tauri-apps/api/event'
import { Button } from '@nextui-org/react'

import { osType } from '../../utils/env'
import './style.css'

export default function WindowControl() {
  const [isMax, setIsMax] = useState(false)

  useEffect(() => {
    // 监听窗口大小变化事件
    listen('tauri://resize', async () => {
      if (await appWindow.isMaximized()) {
        setIsMax(true)
      } else {
        setIsMax(false)
      }
    })
  }, [])

  return (
    <div>
      {/* 最小化按钮 */}
      <Button
        isIconOnly
        variant="light"
        className="h-[35px] w-[35px] rounded-none"
        onPress={() => appWindow.minimize()}
      >
        <VscChromeMinimize className="text-[16px]" />
      </Button>

      {/* 最大化/还原按钮 */}
      <Button
        isIconOnly
        variant="light"
        className="h-[35px] w-[35px] rounded-none"
        onPress={() => {
          if (isMax) {
            appWindow.unmaximize()
          } else {
            appWindow.maximize()
          }
        }}
      >
        {isMax ? <VscChromeRestore className="text-[16px]" /> : <VscChromeMaximize className="text-[16px]" />}
      </Button>

      {/* 关闭按钮 */}
      <Button
        isIconOnly
        variant="light"
        className={`close-button h-[35px] w-[35px] rounded-none ${osType === 'Linux' && 'rounded-tr-[10px]'}`}
        onPress={() => appWindow.close()}
      >
        <VscChromeClose className="text-[16px]" />
      </Button>
    </div>
  )
}
```

**样式文件**: [src/components/WindowControl/style.css](src/components/WindowControl/style.css)

```css
.close-button:hover {
  background-color: #c42b1c !important;
}
```

**功能特点**:

- 使用 VSCode 图标库 (react-icons/vsc) 保持视觉一致性
- 监听窗口大小变化，动态切换最大化/还原图标
- 关闭按钮 hover 时显示红色背景（类似 Windows 11）
- Linux 系统特殊处理：关闭按钮右上角圆角

### 4. 操作系统检测

**文件位置**: [src/utils/env.js](src/utils/env.js)

```javascript
import { type, arch as archFn, version } from '@tauri-apps/api/os'
import { getVersion } from '@tauri-apps/api/app'

export let osType = ''
export let arch = ''
export let osVersion = ''
export let appVersion = ''

export async function initEnv() {
  osType = await type() // 返回 'Darwin', 'Windows_NT', 'Linux' 等
  arch = await archFn() // 返回架构信息
  osVersion = await version() // 返回系统版本
  appVersion = await getVersion() // 返回应用版本
}
```

**返回值说明**:

- `osType === 'Darwin'` → macOS
- `osType === 'Windows_NT'` → Windows
- `osType === 'Linux'` → Linux

## 关键技术点

### 1. 拖拽区域 (Drag Region)

使用 Tauri 提供的 `data-tauri-drag-region` 属性标记可拖拽区域：

```jsx
<div data-tauri-drag-region="true">{/* 这个区域可以拖拽窗口 */}</div>
```

**应用场景**:

- 左侧边栏顶部区域
- Logo 区域
- 右侧标题栏区域

**注意事项**:

- 拖拽区域不能包含可交互元素（如按钮）
- 可以使用 `fixed` 定位创建覆盖层作为拖拽区域

### 2. 条件渲染

根据操作系统类型条件渲染不同的组件：

```jsx
// 仅在非 macOS 系统显示自定义窗口控制按钮
{osType !== 'Darwin' && <WindowControl />}

// Linux 系统特殊样式
className={`${osType === 'Linux' && 'rounded-l-[10px] border-1'}`}
```

### 3. 窗口事件监听

监听 Tauri 窗口事件以同步状态：

```javascript
import { listen } from '@tauri-apps/api/event'

// 监听窗口大小变化
listen('tauri://resize', async () => {
  if (await appWindow.isMaximized()) {
    setIsMax(true)
  } else {
    setIsMax(false)
  }
})
```

**常用事件**:

- `tauri://resize` - 窗口大小变化
- `tauri://move` - 窗口位置变化
- `tauri://close-requested` - 窗口关闭请求
- `tauri://focus` / `tauri://blur` - 窗口焦点变化

### 4. 窗口 API 调用

使用 Tauri 提供的窗口 API 控制窗口行为：

```javascript
import { appWindow } from '@tauri-apps/api/window'

// 最小化
await appWindow.minimize()

// 最大化
await appWindow.maximize()

// 还原
await appWindow.unmaximize()

// 关闭
await appWindow.close()

// 检查是否最大化
const isMaximized = await appWindow.isMaximized()

// 居中
await appWindow.center()

// 设置大小
await appWindow.setSize(new PhysicalSize(800, 600))

// 设置位置
await appWindow.setPosition(new PhysicalPosition(100, 100))
```

## 平台差异化处理

### macOS 平台

**特点**:

- ✅ 移除了标题栏（无标题栏背景和文字）
- ✅ 内容可以延伸到窗口最顶部
- ❌ 保留系统红黄绿按钮（但它们是浮动在内容之上的，不占据布局空间）
- ✅ 前端完全控制标题区域的内容和样式
- ✅ 符合 macOS 设计规范（按钮位于左上角）

**实现方式**:

```rust
// Rust 配置
.title_bar_style(tauri::TitleBarStyle::Overlay)
.hidden_title(true)
```

```jsx
// React 组件 - 不显示自定义窗口控制按钮
{
  osType !== 'Darwin' && <WindowControl />
}
```

**布局说明**:

- 左侧边栏顶部 35px 预留给系统按钮（按钮是浮动的，但需要避免内容被遮挡）
- 标题栏右侧不显示任何自定义按钮
- 拖拽区域需要避开系统按钮位置
- 系统按钮的 hover 效果和点击行为由 macOS 系统处理

### Windows 平台

**特点**:

- 完全自定义标题栏
- 窗口控制按钮位于右上角
- 关闭按钮 hover 显示红色背景（符合 Windows 11 设计）
- 支持窗口阴影效果

**实现方式**:

```rust
// Rust 配置
.transparent(true)
.decorations(false)
```

```rust
// 窗口阴影（仅 Windows/macOS）
#[cfg(not(target_os = "linux"))]
set_shadow(&window, true).unwrap_or_default();
```

**布局说明**:

- 右上角显示最小化、最大化/还原、关闭三个按钮
- 整个标题栏区域可拖拽
- 按钮固定大小 35x35px

### Linux 平台

**特点**:

- 完全自定义标题栏
- 窗口控制按钮位于右上角
- 特殊的圆角和边框处理
- 不启用窗口阴影（性能考虑）

**实现方式**:

```jsx
// 特殊样式处理
className={`${
    osType === 'Linux' && 'rounded-l-[10px] border-1'
}`}

// 关闭按钮右上角圆角
className={`close-button ${osType === 'Linux' && 'rounded-tr-[10px]'}`}

// 高度调整
className={`overflow-y-auto ${
    osType === 'Linux' ? 'h-[calc(100vh-38px)]' : 'h-[calc(100vh-36px)]'
}`}
```

## 配置窗口特殊处理

**文件位置**: [src-tauri/src/window.rs:116-123](src-tauri/src/window.rs#L116-L123)

配置窗口有额外的大小限制：

```rust
pub fn config_window() {
    let (window, _exists) = build_window("config", "Config");

    // 设置最小尺寸
    window
        .set_min_size(Some(tauri::LogicalSize::new(800, 400)))
        .unwrap();

    // 设置默认尺寸
    window.set_size(tauri::LogicalSize::new(800, 600)).unwrap();

    // 窗口居中显示
    window.center().unwrap();
}
```

## 最佳实践总结

### 1. 使用条件编译

在 Rust 代码中使用 `#[cfg]` 宏进行条件编译，避免运行时判断：

```rust
#[cfg(target_os = "macos")]
{
    // macOS 专属代码
}

#[cfg(not(target_os = "macos"))]
{
    // 其他平台代码
}
```

### 2. 合理使用拖拽区域

- 标题栏区域应该可拖拽
- Logo 等装饰性元素也可以设为可拖拽
- 避免在拖拽区域内放置交互元素
- 可以使用 fixed 定位创建透明的拖拽层

### 3. 保持平台一致性

- macOS: 遵循 Apple Human Interface Guidelines
- Windows: 参考 Windows 11 设计规范
- Linux: 参考主流 GTK/Qt 应用

### 4. 性能优化

- Linux 平台不启用窗口阴影（避免性能问题）
- 使用 CSS 变量管理主题
- 合理使用 React 状态管理，避免不必要的重渲染

### 5. 响应式处理

```jsx
// 根据窗口大小调整内容高度
className={`overflow-y-auto ${
    osType === 'Linux' ? 'h-[calc(100vh-38px)]' : 'h-[calc(100vh-36px)]'
}`}
```

## 常见问题

### Q1: macOS 系统按钮被内容遮挡？

**解决方案**: 确保左侧边栏顶部预留足够的空间（至少 35px）

```jsx
<div className="h-[35px] p-[5px]">
  <div className="h-full w-full" data-tauri-drag-region="true" />
</div>
```

### Q2: Windows 窗口无法拖拽？

**解决方案**: 检查拖拽区域是否正确设置 `data-tauri-drag-region='true'`

```jsx
<div data-tauri-drag-region="true" className="...">
  {/* 可拖拽区域 */}
</div>
```

### Q3: 窗口控制按钮点击无反应？

**解决方案**: 确保正确导入并使用 Tauri 的窗口 API

```javascript
import { appWindow } from '@tauri-apps/api/window';

// 确保异步调用
onPress={() => appWindow.minimize()}
```

### Q4: Linux 窗口边框显示异常？

**解决方案**: 检查是否正确应用了条件样式

```jsx
className={`${osType === 'Linux' && 'rounded-l-[10px] border-1'}`}
```

## 扩展阅读

### Tauri 官方文档

- [Window API](https://tauri.app/v1/api/js/window)
- [Window Configuration](https://tauri.app/v1/api/config#windowconfig)
- [TitleBarStyle](https://tauri.app/v1/api/config#titlebarstyle)

### 设计规范参考

- [Apple Human Interface Guidelines](https://developer.apple.com/design/human-interface-guidelines/)
- [Windows 11 Design Principles](https://learn.microsoft.com/en-us/windows/apps/design/)
- [GNOME Human Interface Guidelines](https://developer.gnome.org/hig/)

## 总结

这个跨平台自定义标题栏方案的核心思路是：

1. **所有平台都移除了系统标题栏**:
   - macOS 使用 `TitleBarStyle::Overlay` 让内容覆盖到标题栏位置
   - Windows/Linux 使用 `decorations(false)` 完全移除系统装饰

2. **差异化的窗口控制**:
   - macOS 保留浮动的系统红黄绿按钮（由系统管理）
   - Windows/Linux 使用前端自定义的窗口控制按钮

3. **后端条件编译**: 在 Rust 层面根据目标平台设置不同的窗口属性

4. **前端条件渲染**: 在 React 层面根据运行时检测的操作系统类型显示不同的 UI

5. **平台适配**: 每个平台都保持其原生的设计风格和交互方式

6. **灵活布局**: 使用侧边栏 + 主内容区的布局，左侧预留空间给 macOS 系统按钮，右侧为 Windows/Linux 显示自定义按钮

通过这种方式，既保证了 macOS 的原生按钮体验（符合 Apple 设计规范），又让 Windows/Linux 拥有统一且现代化的完全自定义标题栏样式。所有平台的内容都可以完全控制标题栏区域的外观。
