# LightSync é¡¹ç›®å®ç°æ­¥éª¤ - è¯¦ç»†å®æ–½è®¡åˆ’

## ğŸ“‹ æ–‡æ¡£ä¿¡æ¯

| é¡¹ç›® | å†…å®¹ |
| ---- | ---- |
| **é¡¹ç›®åç§°** | LightSync - è·¨è®¾å¤‡æ–‡ä»¶åŒæ­¥å·¥å…· |
| **æŠ€æœ¯æ ˆ** | Tauri 1.8 + React 18 + Rust + NextUI + TailwindCSS |
| **åˆ›å»ºæ—¥æœŸ** | 2024 |
| **æ–‡æ¡£ç‰ˆæœ¬** | 1.0 |

---

## ğŸ¯ å®ç°æ€»è§ˆ

### æ ¸å¿ƒç›®æ ‡
1. **å­¦ä¹ ç›®æ ‡**: æŒæ¡ Rust/Tauri æŠ€æœ¯æ ˆï¼Œç†è§£ç°ä»£æ¡Œé¢åº”ç”¨å¼€å‘
2. **åŠŸèƒ½ç›®æ ‡**: å®ç°è½»é‡çº§ã€é«˜æ€§èƒ½çš„ WebDAV æ–‡ä»¶åŒæ­¥å·¥å…·
3. **è´¨é‡ç›®æ ‡**: å†…å­˜å ç”¨ < 50MBï¼Œå¯åŠ¨æ—¶é—´ < 3ç§’ï¼ŒåŒæ­¥æˆåŠŸç‡ > 99%

### æŠ€æœ¯é€‰å‹ï¼ˆåŸºäº pot-desktop å­¦ä¹ ï¼‰

| æŠ€æœ¯åˆ†ç±» | é€‰å‹ | ç‰ˆæœ¬ | å‚è€ƒæ¥æº |
| -------- | ---- | ---- | -------- |
| **å‰ç«¯æ¡†æ¶** | React | 18.3.1 | pot-desktop |
| **UIç»„ä»¶åº“** | NextUI | 2.x | pot-desktop |
| **æ ·å¼æ–¹æ¡ˆ** | TailwindCSS | 3.4+ | pot-desktop |
| **çŠ¶æ€ç®¡ç†** | Jotai | æœ€æ–° | pot-desktop |
| **åç«¯è¯­è¨€** | Rust | Edition 2021 | pot-desktop |
| **æ¡Œé¢æ¡†æ¶** | Tauri | 1.8 | pot-desktop |
| **æ„å»ºå·¥å…·** | Vite | 5.x | pot-desktop |
| **WebDAVå®¢æˆ·ç«¯** | reqwest-dav | 0.1.5 | pot-desktop |
| **é…ç½®å­˜å‚¨** | tauri-plugin-store | v1 | pot-desktop |
| **æ•°æ®åº“** | tauri-plugin-sql (SQLite) | v1 | å¿…éœ€ |
| **é”™è¯¯å¤„ç†** | thiserror | 1.0 | pot-desktop |
| **å›½é™…åŒ–** | react-i18next | æœ€æ–° | pot-desktop |

---

## ğŸ“… Phase 1: é¡¹ç›®åŸºç¡€æ­å»º (Week 1)

### ğŸ¯ é˜¶æ®µç›®æ ‡
- å®Œæˆé¡¹ç›®æ¡†æ¶æ­å»º
- å®ç°åŸºç¡€UIéª¨æ¶
- é…ç½®å¼€å‘ç¯å¢ƒ
- å»ºç«‹é…ç½®ç®¡ç†ç³»ç»Ÿ

### ğŸ“ è¯¦ç»†ä»»åŠ¡æ¸…å•

#### Task 1.1: é¡¹ç›®åˆå§‹åŒ– (Day 1-2)

**ç›®æ ‡**: åˆ›å»ºé¡¹ç›®ç»“æ„ï¼Œé…ç½®åŸºç¡€ä¾èµ–

**å®æ–½æ­¥éª¤**:

1. **åˆ›å»º Tauri é¡¹ç›®**
   ```bash
   npm create tauri-app@latest
   # é€‰æ‹©: React + TypeScript + Vite
   ```

2. **é…ç½® `package.json`**
   - å®‰è£…ä¾èµ–: `@nextui-org/react`, `@nextui-org/theme`, `tailwindcss`, `jotai`, `react-i18next`, `i18next`
   - é…ç½®è„šæœ¬: `dev`, `build`, `tauri dev`, `tauri build`

3. **é…ç½® `src-tauri/Cargo.toml`**
   ```toml
   [dependencies]
   tauri = { version = "1.8", features = [
       "dialog-save", "dialog-open", "fs-all", 
       "protocol-asset", "shell-all", "http-all",
       "window-all", "system-tray", "updater"
   ]}
   tauri-plugin-store = { git = "https://github.com/tauri-apps/plugins-workspace", branch = "v1" }
   tauri-plugin-autostart = { git = "https://github.com/tauri-apps/plugins-workspace", branch = "v1" }
   tauri-plugin-single-instance = { git = "https://github.com/tauri-apps/plugins-workspace", branch = "v1" }
   tauri-plugin-log = { git = "https://github.com/tauri-apps/plugins-workspace", branch = "v1" }
   tauri-plugin-sql = { git = "https://github.com/tauri-apps/plugins-workspace", branch = "v1", features = ["sqlite"] }
   
   serde = { version = "1.0", features = ["derive"] }
   serde_json = "1.0"
   once_cell = "1.19.0"
   log = "0.4"
   thiserror = "1.0"
   reqwest = { version = "0.12", features = ["json"] }
   reqwest-dav = "=0.1.5"
   ```

4. **é…ç½® `tauri.conf.json`**
   - è®¾ç½®æœ€å°æƒé™åŸåˆ™ (allowlist: all: false)
   - é…ç½®å®‰å…¨ç­–ç•¥ (CSP)
   - è®¾ç½®åº”ç”¨æ ‡è¯†ç¬¦: `com.lightsync.app`
   - é…ç½®çª—å£å±æ€§: é€æ˜ã€æ— è¾¹æ¡†ã€æœ€å°å°ºå¯¸

**éªŒæ”¶æ ‡å‡†**:
- âœ… é¡¹ç›®å¯ä»¥æˆåŠŸæ„å»º
- âœ… `npm run tauri dev` èƒ½å¯åŠ¨åº”ç”¨
- âœ… åº”ç”¨çª—å£æ­£å¸¸æ˜¾ç¤º

**å‚è€ƒæ–‡æ¡£**: `å¯ç”¨å­¦ä¹ å†…å®¹.md` ç¬¬1èŠ‚ - æŠ€æœ¯æ ˆä¸æ¶æ„

---

#### Task 1.2: ç»Ÿä¸€é”™è¯¯å¤„ç†ç³»ç»Ÿ (Day 2-3)

**ç›®æ ‡**: å»ºç«‹ç»Ÿä¸€çš„é”™è¯¯å¤„ç†æœºåˆ¶

**å®æ–½æ­¥éª¤**:

1. **åˆ›å»º `src-tauri/src/error.rs`**
   ```rust
   #[derive(Debug, thiserror::Error)]
   pub enum SyncError {
       #[error(transparent)]
       Io(#[from] std::io::Error),
       #[error(transparent)]
       WebDav(#[from] reqwest_dav::Error),
       #[error(transparent)]
       Reqwest(#[from] reqwest::Error),
       #[error(transparent)]
       Serde(#[from] serde_json::Error),
       #[error(transparent)]
       Tauri(#[from] tauri::Error),
       #[error("Sync conflict: {0}")]
       Conflict(String),
       #[error("Network error: {0}")]
       Network(String),
       #[error("Authentication failed")]
       AuthError,
       #[error("File not found: {0}")]
       FileNotFound(String),
   }
   
   impl serde::Serialize for SyncError {
       fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
       where
           S: serde::ser::Serializer,
       {
           serializer.serialize_str(self.to_string().as_ref())
       }
   }
   
   pub type Result<T> = std::result::Result<T, SyncError>;
   ```

2. **åœ¨ `main.rs` ä¸­ä½¿ç”¨**
   ```rust
   mod error;
   pub use error::{SyncError, Result};
   ```

**éªŒæ”¶æ ‡å‡†**:
- âœ… æ‰€æœ‰é”™è¯¯ç±»å‹å®šä¹‰å®Œæ•´
- âœ… é”™è¯¯å¯ä»¥åºåˆ—åŒ–ä¼ é€’åˆ°å‰ç«¯
- âœ… ç¼–è¯‘é€šè¿‡ï¼Œæ— è­¦å‘Š

**å‚è€ƒæ–‡æ¡£**: `å¯ç”¨å­¦ä¹ å†…å®¹.md` ç¬¬3èŠ‚ - é”™è¯¯å¤„ç†ä¸ç±»å‹å®‰å…¨

---

#### Task 1.3: é…ç½®ç®¡ç†ç³»ç»Ÿ (Day 3-5)

**ç›®æ ‡**: å®ç°é…ç½®çš„æŒä¹…åŒ–å­˜å‚¨å’ŒåŒæ­¥

**å®æ–½æ­¥éª¤**:

1. **åˆ›å»º `src-tauri/src/config.rs`**
   ```rust
   use tauri_plugin_store::StoreBuilder;
   use std::sync::Mutex;
   use once_cell::sync::OnceCell;
   use dirs::config_dir;
   
   pub static STORE: OnceCell<Mutex<Store>> = OnceCell::new();
   
   pub struct StoreWrapper(pub Mutex<Store>);
   
   pub fn init_config(app: &mut tauri::App) -> Result<()> {
       let config_path = config_dir().unwrap();
       let config_path = config_path.join("lightsync");
       let config_path = config_path.join("config.json");
       
       info!("Load config from: {:?}", config_path);
       let mut store = StoreBuilder::new(app.handle(), config_path).build();
       
       match store.load() {
           Ok(_) => info!("Config loaded"),
           Err(e) => {
               warn!("Config load error: {:?}", e);
               info!("Config not found, creating new config");
           }
       }
       
       app.manage(StoreWrapper(Mutex::new(store)));
       Ok(())
   }
   
   pub fn get(key: &str) -> Option<serde_json::Value> {
       // å®ç°ä» Store è¯»å–é…ç½®
   }
   
   pub fn set(key: &str, value: serde_json::Value) -> Result<()> {
       // å®ç°å‘ Store å†™å…¥é…ç½®
   }
   ```

2. **åˆ›å»ºå‰ç«¯é…ç½® Hook `src/hooks/useConfig.jsx`**
   ```javascript
   import { useCallback, useEffect, useState } from 'react';
   import { store } from '../utils/store';
   import { listen, emit } from '@tauri-apps/api/event';
   import { debounce } from '../utils';
   
   export const useConfig = (key, defaultValue, options = {}) => {
       const [property, setPropertyState] = useState(null);
       const { sync = true } = options;
       
       // åŒæ­¥åˆ°Store (State -> Store)
       const syncToStore = useCallback(
           debounce((v) => {
               store.set(key, v);
               store.save();
               let eventKey = key.replaceAll('.', '_').replaceAll('@', ':');
               emit(`${eventKey}_changed`, v);
           }, 500),
           [key]
       );
       
       // åŒæ­¥åˆ°State (Store -> State)
       const syncToState = useCallback((v) => {
           if (v !== null) {
               setPropertyState(v);
           } else {
               store.get(key).then((v) => {
                   if (v === null) {
                       setPropertyState(defaultValue);
                       store.set(key, defaultValue);
                       store.save();
                   } else {
                       setPropertyState(v);
                   }
               });
           }
       }, [key, defaultValue]);
       
       useEffect(() => {
           syncToState(null);
           const eventKey = key.replaceAll('.', '_').replaceAll('@', ':');
           const unlisten = listen(`${eventKey}_changed`, (e) => {
               syncToState(e.payload);
           });
           
           return () => {
               unlisten.then((f) => f());
           };
       }, []);
       
       const setProperty = useCallback((v) => {
           setPropertyState(v);
           if (sync) {
               syncToStore(v);
           }
       }, [sync, syncToStore]);
       
       return [property, setProperty];
   };
   ```

3. **åˆ›å»º `src/utils/store.js`**
   ```javascript
   import { Store } from 'tauri-plugin-store-api';
   import { appConfigDir, join } from '@tauri-apps/api/path';
   import { watch } from 'tauri-plugin-fs-watch-api';
   import { invoke } from '@tauri-apps/api/core';
   
   export let store = new Store();
   
   export async function initStore() {
       const appConfigDirPath = await appConfigDir();
       const appConfigPath = await join(appConfigDirPath, 'config.json');
       store = new Store(appConfigPath);
       
       // ç›‘å¬é…ç½®æ–‡ä»¶å˜åŒ–
       await watch(appConfigPath, async () => {
           await store.load();
           await invoke('reload_store');
       });
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- âœ… é…ç½®å¯ä»¥æŒä¹…åŒ–ä¿å­˜
- âœ… é…ç½®å˜æ›´å¯ä»¥å®æ—¶åŒæ­¥åˆ°UI
- âœ… æ”¯æŒå¤šçª—å£é…ç½®åŒæ­¥
- âœ… é…ç½®æ–‡ä»¶ç›‘å¬æ­£å¸¸å·¥ä½œ

**å‚è€ƒæ–‡æ¡£**: `å¯ç”¨å­¦ä¹ å†…å®¹.md` ç¬¬2èŠ‚ - é…ç½®ç®¡ç†ä¸æŒä¹…åŒ–

---

#### Task 1.4: SQLite æ•°æ®åº“åˆå§‹åŒ– (Day 4)

**ç›®æ ‡**: åˆå§‹åŒ– SQLite æ•°æ®åº“ï¼Œåˆ›å»ºè¡¨ç»“æ„

**å®æ–½æ­¥éª¤**:

1. **åœ¨ `main.rs` ä¸­æ³¨å†Œ SQL æ’ä»¶**
   ```rust
   // src-tauri/src/main.rs
   use tauri_plugin_sql::{Migration, MigrationKind};
   
   fn main() {
       tauri::Builder::default()
           .plugin(
               tauri_plugin_sql::Builder::default()
                   .add_migrations(
                       "sqlite:lightsync.db",
                       vec![
                           Migration {
                               version: 1,
                               description: "create initial tables",
                               sql: include_str!("../migrations/001_initial.sql"),
                               kind: MigrationKind::Up,
                           },
                       ],
                   )
                   .build(),
           )
           .invoke_handler(tauri::generate_handler![
               // ... å…¶ä»–å‘½ä»¤
           ])
           .run(tauri::generate_context!())
           .expect("error while running tauri application");
   }
   ```

2. **åˆ›å»ºæ•°æ®åº“è¿ç§»æ–‡ä»¶ `src-tauri/migrations/001_initial.sql`**
   ```sql
   -- æ–‡ä»¶å…ƒæ•°æ®è¡¨
   CREATE TABLE IF NOT EXISTS file_metadata (
       id INTEGER PRIMARY KEY AUTOINCREMENT,
       folder_id TEXT NOT NULL,
       relative_path TEXT NOT NULL,
       file_type TEXT NOT NULL, -- 'file' | 'directory'
       size INTEGER,
       modified_time INTEGER, -- Unix timestamp
       content_hash TEXT,
       etag TEXT,
       is_deleted BOOLEAN DEFAULT FALSE,
       last_seen INTEGER,
       created_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now')),
       updated_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now')),
       UNIQUE(folder_id, relative_path)
   );
   
   -- åˆ›å»ºç´¢å¼•ä»¥æå‡æŸ¥è¯¢æ€§èƒ½
   CREATE INDEX IF NOT EXISTS idx_file_metadata_folder_path 
       ON file_metadata(folder_id, relative_path);
   CREATE INDEX IF NOT EXISTS idx_file_metadata_modified 
       ON file_metadata(folder_id, modified_time);
   CREATE INDEX IF NOT EXISTS idx_file_metadata_hash 
       ON file_metadata(content_hash);
   
   -- åŒæ­¥æ“ä½œå†å²è¡¨
   CREATE TABLE IF NOT EXISTS sync_operations (
       id INTEGER PRIMARY KEY AUTOINCREMENT,
       folder_id TEXT NOT NULL,
       operation_type TEXT NOT NULL, -- 'upload' | 'download' | 'delete_remote' | 'delete_local'
       relative_path TEXT NOT NULL,
       status TEXT NOT NULL, -- 'pending' | 'running' | 'completed' | 'failed'
       error_message TEXT,
       file_size INTEGER,
       bytes_transferred INTEGER,
       started_at INTEGER,
       completed_at INTEGER,
       created_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now'))
   );
   
   CREATE INDEX IF NOT EXISTS idx_sync_operations_folder_status 
       ON sync_operations(folder_id, status);
   CREATE INDEX IF NOT EXISTS idx_sync_operations_started 
       ON sync_operations(started_at DESC);
   
   -- é”™è¯¯æ—¥å¿—è¡¨
   CREATE TABLE IF NOT EXISTS error_logs (
       id INTEGER PRIMARY KEY AUTOINCREMENT,
       folder_id TEXT,
       error_type TEXT NOT NULL,
       error_message TEXT NOT NULL,
       stack_trace TEXT,
       relative_path TEXT,
       operation_context TEXT,
       occurred_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now'))
   );
   
   CREATE INDEX IF NOT EXISTS idx_error_logs_folder_time 
       ON error_logs(folder_id, occurred_at DESC);
   CREATE INDEX IF NOT EXISTS idx_error_logs_type 
       ON error_logs(error_type);
   ```

3. **åˆ›å»ºæ•°æ®åº“æ“ä½œæ¨¡å— `src-tauri/src/database.rs`**
   ```rust
   use tauri::AppHandle;
   use serde::{Deserialize, Serialize};
   
   #[derive(Debug, Clone, Serialize, Deserialize)]
   pub struct FileMetadata {
       pub id: Option<i64>,
       pub folder_id: String,
       pub relative_path: String,
       pub file_type: String,
       pub size: Option<i64>,
       pub modified_time: Option<i64>,
       pub content_hash: Option<String>,
       pub etag: Option<String>,
       pub is_deleted: bool,
       pub last_seen: Option<i64>,
   }
   
   pub async fn save_file_metadata(
       app: &AppHandle,
       metadata: &FileMetadata,
   ) -> Result<i64, String> {
       let db = app.state::<tauri_plugin_sql::DbInstance>();
       
       let sql = r#"
           INSERT OR REPLACE INTO file_metadata 
           (folder_id, relative_path, file_type, size, modified_time, content_hash, etag, is_deleted, last_seen, updated_at)
           VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, strftime('%s', 'now'))
           RETURNING id
       "#;
       
       let result: Vec<(i64,)> = db
           .select(sql, &[
               &metadata.folder_id,
               &metadata.relative_path,
               &metadata.file_type,
               &metadata.size,
               &metadata.modified_time,
               &metadata.content_hash,
               &metadata.etag,
               &metadata.is_deleted,
               &metadata.last_seen,
           ])
           .await
           .map_err(|e| e.to_string())?;
       
       Ok(result[0].0)
   }
   
   pub async fn get_file_metadata(
       app: &AppHandle,
       folder_id: &str,
       relative_path: &str,
   ) -> Result<Option<FileMetadata>, String> {
       let db = app.state::<tauri_plugin_sql::DbInstance>();
       
       let sql = r#"
           SELECT id, folder_id, relative_path, file_type, size, 
                  modified_time, content_hash, etag, is_deleted, last_seen
           FROM file_metadata
           WHERE folder_id = ? AND relative_path = ?
       "#;
       
       let result: Vec<(Option<i64>, String, String, String, Option<i64>, Option<i64>, Option<String>, Option<String>, bool, Option<i64>)> = db
           .select(sql, &[folder_id, relative_path])
           .await
           .map_err(|e| e.to_string())?;
       
       if result.is_empty() {
           return Ok(None);
       }
       
       let row = &result[0];
       Ok(Some(FileMetadata {
           id: row.0,
           folder_id: row.1.clone(),
           relative_path: row.2.clone(),
           file_type: row.3.clone(),
           size: row.4,
           modified_time: row.5,
           content_hash: row.6.clone(),
           etag: row.7.clone(),
           is_deleted: row.8,
           last_seen: row.9,
       }))
   }
   
   pub async fn get_all_files_in_folder(
       app: &AppHandle,
       folder_id: &str,
   ) -> Result<Vec<FileMetadata>, String> {
       let db = app.state::<tauri_plugin_sql::DbInstance>();
       
       let sql = r#"
           SELECT id, folder_id, relative_path, file_type, size, 
                  modified_time, content_hash, etag, is_deleted, last_seen
           FROM file_metadata
           WHERE folder_id = ? AND is_deleted = FALSE
           ORDER BY relative_path
       "#;
       
       let result: Vec<(Option<i64>, String, String, String, Option<i64>, Option<i64>, Option<String>, Option<String>, bool, Option<i64>)> = db
           .select(sql, &[folder_id])
           .await
           .map_err(|e| e.to_string())?;
       
       Ok(result.iter().map(|row| FileMetadata {
           id: row.0,
           folder_id: row.1.clone(),
           relative_path: row.2.clone(),
           file_type: row.3.clone(),
           size: row.4,
           modified_time: row.5,
           content_hash: row.6.clone(),
           etag: row.7.clone(),
           is_deleted: row.8,
           last_seen: row.9,
       }).collect())
   }
   ```

4. **åˆ›å»º Tauri å‘½ä»¤æš´éœ²æ•°æ®åº“æ“ä½œ**
   ```rust
   // src-tauri/src/main.rs
   mod database;
   
   #[tauri::command]
   async fn save_file_metadata(
       app: AppHandle,
       metadata: FileMetadata,
   ) -> Result<i64, String> {
       database::save_file_metadata(&app, &metadata).await
   }
   
   #[tauri::command]
   async fn get_file_metadata(
       app: AppHandle,
       folder_id: String,
       relative_path: String,
   ) -> Result<Option<FileMetadata>, String> {
       database::get_file_metadata(&app, &folder_id, &relative_path).await
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- âœ… SQLite æ•°æ®åº“æˆåŠŸåˆå§‹åŒ–
- âœ… æ‰€æœ‰è¡¨ç»“æ„åˆ›å»ºæˆåŠŸ
- âœ… ç´¢å¼•åˆ›å»ºæˆåŠŸ
- âœ… æ•°æ®åº“æ“ä½œå‡½æ•°æ­£å¸¸å·¥ä½œ
- âœ… è¿ç§»æœºåˆ¶æ­£å¸¸å·¥ä½œ

**å‚è€ƒæ–‡æ¡£**: `SQLiteä½¿ç”¨å¿…è¦æ€§åˆ†æ.md`

---

#### Task 1.5: å›½é™…åŒ–ç³»ç»Ÿæ­å»º (Day 5)

**ç›®æ ‡**: é…ç½® i18nextï¼Œå»ºç«‹å›½é™…åŒ–åŸºç¡€æ¶æ„

**å®æ–½æ­¥éª¤**:

1. **å®‰è£…å›½é™…åŒ–ä¾èµ–**
   ```bash
   npm install react-i18next i18next
   ```

2. **åˆ›å»ºå›½é™…åŒ–é…ç½®æ–‡ä»¶ `src/i18n/index.js`**
   ```javascript
   import i18n from 'i18next';
   import { initReactI18next } from 'react-i18next';
   import zhCN from './locales/zh-CN.json';
   import enUS from './locales/en-US.json';

   i18n.use(initReactI18next).init({
       resources: {
           'zh-CN': { translation: zhCN },
           'en-US': { translation: enUS },
       },
       lng: 'zh-CN', // é»˜è®¤è¯­è¨€
       fallbackLng: {
           zh_TW: ['zh-CN'],
           zh_CN: ['zh-CN'],
           default: ['en-US'],
       },
       debug: false,
       interpolation: {
           escapeValue: false, // React å·²ç»é˜²æ­¢ XSS
       },
   });

   export default i18n;
   ```

3. **åˆ›å»ºç¿»è¯‘æ–‡ä»¶ç»“æ„**
   ```
   src/i18n/
   â”œâ”€â”€ index.js
   â””â”€â”€ locales/
       â”œâ”€â”€ zh-CN.json
       â””â”€â”€ en-US.json
   ```

4. **åˆ›å»ºä¸­æ–‡ç¿»è¯‘æ–‡ä»¶ `src/i18n/locales/zh-CN.json`**
   ```json
   {
     "common": {
       "save": "ä¿å­˜",
       "cancel": "å–æ¶ˆ",
       "delete": "åˆ é™¤",
       "confirm": "ç¡®è®¤",
       "loading": "åŠ è½½ä¸­...",
       "error": "é”™è¯¯",
       "success": "æˆåŠŸ"
     },
     "sync": {
       "title": "åŒæ­¥çŠ¶æ€",
       "now": "ç«‹å³åŒæ­¥",
       "pause": "æš‚åœåŒæ­¥",
       "resume": "æ¢å¤åŒæ­¥",
       "status": "åŒæ­¥çŠ¶æ€",
       "progress": "åŒæ­¥è¿›åº¦",
       "complete": "åŒæ­¥å®Œæˆ",
       "error": "åŒæ­¥å¤±è´¥",
       "fileCount": "å…±æœ‰ {{count}} ä¸ªæ–‡ä»¶",
       "lastSync": "æœ€ååŒæ­¥: {{time}}",
       "activeTasks": "{{count}} ä¸ªæ–‡ä»¶å¤¹æ­£åœ¨åŒæ­¥"
     },
     "server": {
       "title": "æœåŠ¡å™¨é…ç½®",
       "add": "æ·»åŠ æœåŠ¡å™¨",
       "edit": "ç¼–è¾‘æœåŠ¡å™¨",
       "delete": "åˆ é™¤æœåŠ¡å™¨",
       "test": "æµ‹è¯•è¿æ¥",
       "name": "æœåŠ¡å™¨åç§°",
       "url": "WebDAV URL",
       "username": "ç”¨æˆ·å",
       "password": "å¯†ç ",
       "connectionSuccess": "è¿æ¥æˆåŠŸ",
       "connectionFailed": "è¿æ¥å¤±è´¥"
     },
     "folder": {
       "title": "åŒæ­¥æ–‡ä»¶å¤¹",
       "add": "æ·»åŠ åŒæ­¥æ–‡ä»¶å¤¹",
       "edit": "ç¼–è¾‘æ–‡ä»¶å¤¹",
       "delete": "åˆ é™¤æ–‡ä»¶å¤¹",
       "localPath": "æœ¬åœ°è·¯å¾„",
       "remotePath": "è¿œç¨‹è·¯å¾„",
       "syncDirection": "åŒæ­¥æ–¹å‘",
       "both": "åŒå‘åŒæ­¥",
       "upload": "ä»…ä¸Šä¼ ",
       "download": "ä»…ä¸‹è½½"
     },
     "settings": {
       "title": "è®¾ç½®",
       "general": "é€šç”¨",
       "language": "è¯­è¨€",
       "theme": "ä¸»é¢˜",
       "autoStart": "å¼€æœºè‡ªå¯",
       "minimizeToTray": "æœ€å°åŒ–åˆ°æ‰˜ç›˜"
     }
   }
   ```

5. **åˆ›å»ºè‹±æ–‡ç¿»è¯‘æ–‡ä»¶ `src/i18n/locales/en-US.json`**
   ```json
   {
     "common": {
       "save": "Save",
       "cancel": "Cancel",
       "delete": "Delete",
       "confirm": "Confirm",
       "loading": "Loading...",
       "error": "Error",
       "success": "Success"
     },
     "sync": {
       "title": "Sync Status",
       "now": "Sync Now",
       "pause": "Pause Sync",
       "resume": "Resume Sync",
       "status": "Sync Status",
       "progress": "Sync Progress",
       "complete": "Sync Complete",
       "error": "Sync Failed",
       "fileCount": "{{count}} files in total",
       "lastSync": "Last sync: {{time}}",
       "activeTasks": "{{count}} folders syncing"
     },
     "server": {
       "title": "Server Configuration",
       "add": "Add Server",
       "edit": "Edit Server",
       "delete": "Delete Server",
       "test": "Test Connection",
       "name": "Server Name",
       "url": "WebDAV URL",
       "username": "Username",
       "password": "Password",
       "connectionSuccess": "Connection successful",
       "connectionFailed": "Connection failed"
     },
     "folder": {
       "title": "Sync Folders",
       "add": "Add Sync Folder",
       "edit": "Edit Folder",
       "delete": "Delete Folder",
       "localPath": "Local Path",
       "remotePath": "Remote Path",
       "syncDirection": "Sync Direction",
       "both": "Bidirectional",
       "upload": "Upload Only",
       "download": "Download Only"
     },
     "settings": {
       "title": "Settings",
       "general": "General",
       "language": "Language",
       "theme": "Theme",
       "autoStart": "Auto Start",
       "minimizeToTray": "Minimize to Tray"
     }
   }
   ```

6. **åœ¨ `src/main.jsx` ä¸­åˆå§‹åŒ– i18n**
   ```javascript
   import React from 'react';
   import ReactDOM from 'react-dom/client';
   import App from './App';
   import './i18n'; // å¯¼å…¥ i18n é…ç½®
   import './index.css';

   ReactDOM.createRoot(document.getElementById('root')).render(
       <React.StrictMode>
           <App />
       </React.StrictMode>
   );
   ```

7. **åˆ›å»ºè¯­è¨€åˆ‡æ¢ Hook `src/hooks/useLanguage.jsx`**
   ```javascript
   import { useTranslation } from 'react-i18next';
   import { useConfig } from './useConfig';
   import { useEffect } from 'react';

   export function useLanguage() {
       const { i18n } = useTranslation();
       const [language, setLanguage] = useConfig('language', 'zh-CN');

       const changeLanguage = (lng) => {
           i18n.changeLanguage(lng);
           setLanguage(lng);
       };

       // ä»é…ç½®åŠ è½½è¯­è¨€
       useEffect(() => {
           if (language) {
               i18n.changeLanguage(language);
           }
       }, []);

       return {
           language,
           changeLanguage,
           t: useTranslation().t,
       };
   }
   ```

8. **åˆ›å»ºæ–‡æœ¬å¸¸é‡æ–‡ä»¶ `src/constants/text.js`ï¼ˆæ¸è¿›å¼æ–¹æ¡ˆï¼‰**
   ```javascript
   // å³ä½¿ä½¿ç”¨ i18nï¼Œä¹Ÿå»ºè®®å…ˆæå–æ–‡æœ¬å¸¸é‡ï¼Œæ–¹ä¾¿åç»­ç»´æŠ¤
   // åç»­å¯ä»¥é€æ­¥è¿ç§»åˆ°ç¿»è¯‘æ–‡ä»¶
   
   export const TEXT_KEYS = {
       common: {
           save: 'common.save',
           cancel: 'common.cancel',
           delete: 'common.delete',
           confirm: 'common.confirm',
           loading: 'common.loading',
           error: 'common.error',
           success: 'common.success',
       },
       sync: {
           now: 'sync.now',
           pause: 'sync.pause',
           resume: 'sync.resume',
           status: 'sync.status',
           progress: 'sync.progress',
           complete: 'sync.complete',
           error: 'sync.error',
           fileCount: 'sync.fileCount',
           lastSync: 'sync.lastSync',
           activeTasks: 'sync.activeTasks',
       },
       server: {
           add: 'server.add',
           edit: 'server.edit',
           delete: 'server.delete',
           test: 'server.test',
           name: 'server.name',
           url: 'server.url',
           username: 'server.username',
           password: 'server.password',
           connectionSuccess: 'server.connectionSuccess',
           connectionFailed: 'server.connectionFailed',
       },
   };
   
   // ä¾¿æ·å‡½æ•°ï¼šä½¿ç”¨ç¿»è¯‘ key
   export function useText() {
       const { t } = useTranslation();
       return (key) => t(key);
   }
   ```

9. **åœ¨ç»„ä»¶ä¸­ä½¿ç”¨å›½é™…åŒ–**
   ```jsx
   // src/components/SyncButton.jsx
   import { useTranslation } from 'react-i18next';
   import { Button } from '@nextui-org/react';
   
   export default function SyncButton({ onClick, disabled }) {
       const { t } = useTranslation();
       
       return (
           <Button 
               onClick={onClick} 
               disabled={disabled}
               color="primary"
           >
               {t('sync.now')}
           </Button>
       );
   }
   
   // ä½¿ç”¨æ’å€¼
   function SyncStatus({ fileCount, lastSyncTime }) {
       const { t } = useTranslation();
       
       return (
           <div>
               <p>{t('sync.fileCount', { count: fileCount })}</p>
               <p>{t('sync.lastSync', { time: formatTime(lastSyncTime) })}</p>
           </div>
       );
   }
   ```

10. **æ·»åŠ è¯­è¨€åˆ‡æ¢ç»„ä»¶ `src/components/LanguageSwitcher.jsx`**
    ```jsx
    import { Select, SelectItem } from '@nextui-org/react';
    import { useLanguage } from '../hooks/useLanguage';
    
    export default function LanguageSwitcher() {
        const { language, changeLanguage } = useLanguage();
        
        return (
            <Select
                selectedKeys={[language]}
                onSelectionChange={(keys) => {
                    const lng = Array.from(keys)[0];
                    changeLanguage(lng);
                }}
                label="è¯­è¨€"
            >
                <SelectItem key="zh-CN">ç®€ä½“ä¸­æ–‡</SelectItem>
                <SelectItem key="en-US">English</SelectItem>
            </Select>
        );
    }
    ```

**éªŒæ”¶æ ‡å‡†**:
- âœ… i18next é…ç½®æ­£ç¡®
- âœ… ä¸­è‹±æ–‡ç¿»è¯‘æ–‡ä»¶å®Œæ•´
- âœ… è¯­è¨€åˆ‡æ¢åŠŸèƒ½æ­£å¸¸
- âœ… ç¿»è¯‘å¯ä»¥æ­£ç¡®æ˜¾ç¤º
- âœ… ç»„ä»¶ä¸­æ­£ç¡®ä½¿ç”¨ `t()` å‡½æ•°
- âœ… æ’å€¼åŠŸèƒ½æ­£å¸¸å·¥ä½œ

**å‚è€ƒæ–‡æ¡£**: `å¯ç”¨å­¦ä¹ å†…å®¹.md` ç¬¬8èŠ‚ - å›½é™…åŒ–æ”¯æŒ

---

#### Task 1.6: åŸºç¡€UIæ¡†æ¶æ­å»º (Day 6-7)

**ç›®æ ‡**: æ­å»ºä¸»ç•Œé¢æ¡†æ¶ï¼Œå®ç°ä¸»é¢˜ç³»ç»Ÿ

**å®æ–½æ­¥éª¤**:

1. **é…ç½® TailwindCSS + NextUI**
   ```javascript
   // tailwind.config.js
   const { nextui } = require("@nextui-org/react");
   
   module.exports = {
       content: [
           "./index.html",
           "./src/**/*.{js,ts,jsx,tsx}",
           "./node_modules/@nextui-org/theme/dist/**/*.{js,ts,jsx,tsx}"
       ],
       theme: {
           extend: {},
       },
       darkMode: "class",
       plugins: [nextui()],
   };
   ```

2. **åˆ›å»ºä¸»å¸ƒå±€ç»„ä»¶ `src/components/Layout.jsx`**
   ```jsx
   import { NextUIProvider } from '@nextui-org/react';
   import { ThemeProvider as NextThemesProvider } from 'next-themes';
   import { I18nextProvider } from 'react-i18next';
   import i18n from '../i18n';
   
   export default function Layout({ children }) {
       return (
           <I18nextProvider i18n={i18n}>
               <NextUIProvider>
                   <NextThemesProvider attribute="class" defaultTheme="system">
                       <div className="min-h-screen bg-background">
                           {children}
                       </div>
                   </NextThemesProvider>
               </NextUIProvider>
           </I18nextProvider>
       );
   }
   ```

3. **åˆ›å»ºä¸»çª—å£ `src/App.jsx`**
   ```jsx
   import { BrowserRouter, Routes, Route } from 'react-router-dom';
   import Layout from './components/Layout';
   import HomePage from './pages/Home';
   import ConfigPage from './pages/Config';
   
   function App() {
       return (
           <Layout>
               <BrowserRouter>
                   <Routes>
                       <Route path="/" element={<HomePage />} />
                       <Route path="/config" element={<ConfigPage />} />
                   </Routes>
               </BrowserRouter>
           </Layout>
       );
   }
   ```

4. **åˆ›å»ºé¦–é¡µ `src/pages/Home.jsx`**ï¼ˆä½¿ç”¨å›½é™…åŒ–ï¼‰
   ```jsx
   import { useTranslation } from 'react-i18next';
   import { Button, Card } from '@nextui-org/react';
   
   export default function HomePage() {
       const { t } = useTranslation();
       
       return (
           <div className="p-4">
               <h1>{t('sync.title')}</h1>
               <Card className="p-4">
                   <p>{t('sync.status')}</p>
                   <Button>{t('sync.now')}</Button>
               </Card>
           </div>
       );
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- âœ… UIæ­£å¸¸æ˜¾ç¤ºï¼Œæ”¯æŒæ·±è‰²/æµ…è‰²ä¸»é¢˜åˆ‡æ¢
- âœ… è·¯ç”±å¯¼èˆªæ­£å¸¸å·¥ä½œ
- âœ… å“åº”å¼å¸ƒå±€é€‚é…ä¸åŒçª—å£å°ºå¯¸
- âœ… æ‰€æœ‰æ–‡æœ¬ä½¿ç”¨å›½é™…åŒ–ç¿»è¯‘
- âœ… è¯­è¨€åˆ‡æ¢åŠŸèƒ½æ­£å¸¸

**å‚è€ƒæ–‡æ¡£**: `å¯ç”¨å­¦ä¹ å†…å®¹.md` ç¬¬10èŠ‚ - UI/UXè®¾è®¡

---

### ğŸ“Š Phase 1 äº¤ä»˜ç‰©æ£€æŸ¥æ¸…å•

- [ ] é¡¹ç›®å¯ä»¥æˆåŠŸæ„å»ºå’Œè¿è¡Œ
- [ ] é…ç½®ç®¡ç†ç³»ç»Ÿæ­£å¸¸å·¥ä½œ
- [ ] é”™è¯¯å¤„ç†ç³»ç»Ÿå®Œæ•´
- [ ] SQLite æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ
- [ ] å›½é™…åŒ–ç³»ç»Ÿé…ç½®å®Œæˆ
- [ ] åŸºç¡€UIæ¡†æ¶æ­å»ºå®Œæˆ
- [ ] ä¸»é¢˜åˆ‡æ¢åŠŸèƒ½æ­£å¸¸
- [ ] è¯­è¨€åˆ‡æ¢åŠŸèƒ½æ­£å¸¸

---

## ğŸ“… Phase 2: WebDAV è¿æ¥ä¸è®¤è¯ (Week 2)

### ğŸ¯ é˜¶æ®µç›®æ ‡
- å®ç° WebDAV æœåŠ¡å™¨è¿æ¥
- å®ç°è®¤è¯ç®¡ç†
- å®ç°è¿æ¥æµ‹è¯•åŠŸèƒ½
- å®ŒæˆæœåŠ¡å™¨é…ç½®ç•Œé¢

### ğŸ“ è¯¦ç»†ä»»åŠ¡æ¸…å•

#### Task 2.1: WebDAV å®¢æˆ·ç«¯å°è£… (Day 1-3)

**ç›®æ ‡**: å°è£… WebDAV æ“ä½œï¼Œå®ç°è¿æ¥å’Œè®¤è¯

**å®æ–½æ­¥éª¤**:

1. **åˆ›å»º `src-tauri/src/webdav.rs`**
   ```rust
   use reqwest_dav::{Auth, ClientBuilder, Depth};
   use crate::error::{Result, SyncError};
   use serde::{Deserialize, Serialize};
   
   #[derive(Debug, Clone, Serialize, Deserialize)]
   pub struct ServerConfig {
       pub id: String,
       pub name: String,
       pub url: String,
       pub username: String,
       pub password: String, // å°†ä»å¯†é’¥ç¯è¯»å–
       pub timeout: u64,
       pub verify_ssl: bool,
   }
   
   pub struct WebDavClient {
       client: reqwest_dav::Client,
       config: ServerConfig,
   }
   
   impl WebDavClient {
       pub fn new(config: ServerConfig) -> Result<Self> {
           let client = ClientBuilder::new()
               .set_host(config.url.clone())
               .set_auth(Auth::Basic(
                   config.username.clone(),
                   config.password.clone(),
               ))
               .build()?;
           
           Ok(Self { client, config })
       }
       
       pub async fn test_connection(&self) -> Result<()> {
           // å‘é€ PROPFIND è¯·æ±‚æµ‹è¯•è¿æ¥
           let _ = self.client.list("/", Depth::Number(0)).await?;
           Ok(())
       }
       
       pub async fn list(&self, path: &str, depth: Depth) -> Result<Vec<FileInfo>> {
           let res = self.client.list(path, depth).await?;
           // è§£ææ–‡ä»¶åˆ—è¡¨
           Ok(parse_file_list(res))
       }
       
       pub async fn upload(&self, local_path: &Path, remote_path: &str) -> Result<()> {
           let data = std::fs::read(local_path)?;
           self.client.put(remote_path, data).await?;
           Ok(())
       }
       
       pub async fn download(&self, remote_path: &str, local_path: &Path) -> Result<()> {
           let res = self.client.get(remote_path).await?;
           let data = res.bytes().await?;
           std::fs::write(local_path, data)?;
           Ok(())
       }
       
       pub async fn delete(&self, remote_path: &str) -> Result<()> {
           self.client.delete(remote_path).await?;
           Ok(())
       }
   }
   ```

2. **å®ç°å¯†ç å®‰å…¨å­˜å‚¨**
   ```rust
   // ä½¿ç”¨ keyring crate
   use keyring::Entry;
   
   pub fn save_password(service: &str, username: &str, password: &str) -> Result<()> {
       let entry = Entry::new(service, username)?;
       entry.set_password(password)?;
       Ok(())
   }
   
   pub fn get_password(service: &str, username: &str) -> Result<String> {
       let entry = Entry::new(service, username)?;
       entry.get_password()
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- âœ… å¯ä»¥æˆåŠŸè¿æ¥ WebDAV æœåŠ¡å™¨
- âœ… æ”¯æŒ Basic è®¤è¯
- âœ… å¯†ç ä½¿ç”¨ç³»ç»Ÿå¯†é’¥ç¯å­˜å‚¨
- âœ… è¿æ¥æµ‹è¯•åŠŸèƒ½æ­£å¸¸

**å‚è€ƒæ–‡æ¡£**: `å¯ç”¨å­¦ä¹ å†…å®¹.md` ç¬¬12èŠ‚ - æ–‡ä»¶å¤‡ä»½ä¸åŒæ­¥

---

#### Task 2.2: Tauri å‘½ä»¤æš´éœ² (Day 3-4)

**ç›®æ ‡**: å°† WebDAV æ“ä½œæš´éœ²ä¸ºå‰ç«¯å¯è°ƒç”¨çš„å‘½ä»¤

**å®æ–½æ­¥éª¤**:

1. **åœ¨ `main.rs` ä¸­æ³¨å†Œå‘½ä»¤**
   ```rust
   #[tauri::command(async)]
   async fn test_webdav_connection(
       url: String,
       username: String,
       password: String,
   ) -> Result<bool, String> {
       let config = ServerConfig {
           id: "test".to_string(),
           name: "Test".to_string(),
           url,
           username,
           password,
           timeout: 30,
           verify_ssl: true,
       };
       
       match WebDavClient::new(config) {
           Ok(client) => {
               match client.test_connection().await {
                   Ok(_) => Ok(true),
                   Err(e) => Err(e.to_string()),
               }
           }
           Err(e) => Err(e.to_string()),
       }
   }
   
   #[tauri::command]
   fn save_server_config(config: ServerConfig) -> Result<(), String> {
       // ä¿å­˜æœåŠ¡å™¨é…ç½®åˆ° Store
       // å¯†ç ä¿å­˜åˆ°å¯†é’¥ç¯
       Ok(())
   }
   
   #[tauri::command]
   fn get_server_configs() -> Result<Vec<ServerConfig>, String> {
       // ä» Store è¯»å–æœåŠ¡å™¨é…ç½®åˆ—è¡¨
       // å¯†ç ä»å¯†é’¥ç¯è¯»å–
       Ok(vec![])
   }
   ```

2. **åœ¨å‰ç«¯è°ƒç”¨**
   ```javascript
   import { invoke } from '@tauri-apps/api/core';
   
   export async function testConnection(url, username, password) {
       try {
           const result = await invoke('test_webdav_connection', {
               url,
               username,
               password,
           });
           return { success: result, error: null };
       } catch (error) {
           return { success: false, error: error.message };
       }
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- âœ… å‰ç«¯å¯ä»¥è°ƒç”¨ Rust å‘½ä»¤
- âœ… é”™è¯¯ä¿¡æ¯æ­£ç¡®ä¼ é€’
- âœ… å¼‚æ­¥æ“ä½œä¸é˜»å¡UI

**å‚è€ƒæ–‡æ¡£**: `å¯ç”¨å­¦ä¹ å†…å®¹.md` ç¬¬5èŠ‚ - æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯

---

#### Task 2.3: æœåŠ¡å™¨é…ç½®ç•Œé¢ (Day 4-7)

**ç›®æ ‡**: å®ç°æœåŠ¡å™¨æ·»åŠ ã€ç¼–è¾‘ã€åˆ é™¤ç•Œé¢

**å®æ–½æ­¥éª¤**:

1. **åˆ›å»ºæœåŠ¡å™¨é…ç½®è¡¨å• `src/components/ServerConfigForm.jsx`**
   ```jsx
   import { Input, Button, Card } from '@nextui-org/react';
   import { useState } from 'react';
   import { testConnection, saveServerConfig } from '../utils/webdav';
   
   export default function ServerConfigForm({ onSuccess }) {
       const [formData, setFormData] = useState({
           name: '',
           url: '',
           username: '',
           password: '',
           timeout: 30,
       });
       const [testing, setTesting] = useState(false);
       const [error, setError] = useState(null);
       
       const handleTest = async () => {
           setTesting(true);
           setError(null);
           const result = await testConnection(
               formData.url,
               formData.username,
               formData.password
           );
           if (!result.success) {
               setError(result.error);
           }
           setTesting(false);
       };
       
       const handleSave = async () => {
           // ä¿å­˜é…ç½®
           await saveServerConfig(formData);
           onSuccess();
       };
       
       return (
           <Card className="p-4">
               <Input
                   label="æœåŠ¡å™¨åç§°"
                   value={formData.name}
                   onChange={(e) => setFormData({...formData, name: e.target.value})}
               />
               {/* å…¶ä»–å­—æ®µ */}
               <Button onClick={handleTest} isLoading={testing}>
                   æµ‹è¯•è¿æ¥
               </Button>
               <Button onClick={handleSave} color="primary">
                   ä¿å­˜
               </Button>
           </Card>
       );
   }
   ```

2. **åˆ›å»ºæœåŠ¡å™¨åˆ—è¡¨é¡µé¢ `src/pages/Servers.jsx`**
   - æ˜¾ç¤ºå·²é…ç½®çš„æœåŠ¡å™¨åˆ—è¡¨
   - æ”¯æŒæ·»åŠ ã€ç¼–è¾‘ã€åˆ é™¤æ“ä½œ
   - æ˜¾ç¤ºè¿æ¥çŠ¶æ€

**éªŒæ”¶æ ‡å‡†**:
- âœ… å¯ä»¥æ·»åŠ æœåŠ¡å™¨é…ç½®
- âœ… è¿æ¥æµ‹è¯•åŠŸèƒ½æ­£å¸¸
- âœ… è¡¨å•éªŒè¯å®Œæ•´
- âœ… å¯†ç å®‰å…¨å­˜å‚¨

**å‚è€ƒæ–‡æ¡£**: `é¡¹ç›®éœ€æ±‚åˆ†æ.md` UC-001 - é…ç½®WebDAVæœåŠ¡å™¨è¿æ¥

---

### ğŸ“Š Phase 2 äº¤ä»˜ç‰©æ£€æŸ¥æ¸…å•

- [ ] WebDAV å®¢æˆ·ç«¯å°è£…å®Œæˆ
- [ ] æ”¯æŒè¿æ¥æµ‹è¯•
- [ ] å¯†ç å®‰å…¨å­˜å‚¨å®ç°
- [ ] æœåŠ¡å™¨é…ç½®ç•Œé¢å®Œæˆ
- [ ] æ”¯æŒä¸»æµ WebDAV æœåŠ¡å•†ï¼ˆåšæœäº‘ã€NextCloudç­‰ï¼‰

---

## ğŸ“… Phase 3: æ–‡ä»¶ç³»ç»Ÿç›‘æ§ (Week 3)

### ğŸ¯ é˜¶æ®µç›®æ ‡
- å®ç°æ–‡ä»¶ç³»ç»Ÿç›‘æ§
- å®ç°æ–‡ä»¶å˜æ›´æ£€æµ‹
- å®ç°äº‹ä»¶æ‰¹å¤„ç†
- å®ç°å¿½ç•¥è§„åˆ™è¿‡æ»¤

### ğŸ“ è¯¦ç»†ä»»åŠ¡æ¸…å•

#### Task 3.1: æ–‡ä»¶ç›‘æ§å®ç° (Day 1-4)

**ç›®æ ‡**: ä½¿ç”¨ notify crate ç›‘æ§æ–‡ä»¶ç³»ç»Ÿå˜åŒ–

**å®æ–½æ­¥éª¤**:

1. **æ·»åŠ ä¾èµ–**
   ```toml
   [dependencies]
   notify = "6.0"
   ```

2. **åˆ›å»º `src-tauri/src/file_watcher.rs`**
   ```rust
   use notify::{Watcher, RecommendedWatcher, RecursiveMode, Event, EventKind};
   use std::path::PathBuf;
   use std::collections::HashMap;
   use std::sync::mpsc;
   use crate::error::Result;
   
   pub struct FileWatcher {
       watchers: HashMap<PathBuf, RecommendedWatcher>,
       event_tx: mpsc::Sender<FileEvent>,
   }
   
   #[derive(Debug, Clone)]
   pub struct FileEvent {
       pub path: PathBuf,
       pub kind: EventKind,
       pub timestamp: u64,
   }
   
   impl FileWatcher {
       pub fn new() -> (Self, mpsc::Receiver<FileEvent>) {
           let (tx, rx) = mpsc::channel();
           (Self {
               watchers: HashMap::new(),
               event_tx: tx,
           }, rx)
       }
       
       pub fn watch_directory(&mut self, path: PathBuf) -> Result<()> {
           let mut watcher = notify::recommended_watcher(
               move |res: notify::Result<Event>| {
                   match res {
                       Ok(event) => {
                           for path in event.paths {
                               let file_event = FileEvent {
                                   path,
                                   kind: event.kind.clone(),
                                   timestamp: std::time::SystemTime::now()
                                       .duration_since(std::time::UNIX_EPOCH)
                                       .unwrap()
                                       .as_secs(),
                               };
                               self.event_tx.send(file_event).ok();
                           }
                       }
                       Err(e) => {
                           error!("Watch error: {:?}", e);
                       }
                   }
               }
           )?;
           
           watcher.watch(&path, RecursiveMode::Recursive)?;
           self.watchers.insert(path, watcher);
           Ok(())
       }
       
       pub fn unwatch_directory(&mut self, path: &PathBuf) -> Result<()> {
           self.watchers.remove(path);
           Ok(())
       }
   }
   ```

3. **å®ç°äº‹ä»¶è¿‡æ»¤å’Œæ‰¹å¤„ç†**
   ```rust
   pub struct EventBatcher {
       events: Vec<FileEvent>,
       batch_window: Duration,
       last_batch: Instant,
   }
   
   impl EventBatcher {
       pub fn add_event(&mut self, event: FileEvent) -> Option<Vec<FileEvent>> {
           self.events.push(event);
           
           if self.last_batch.elapsed() >= self.batch_window {
               let batch = self.events.clone();
               self.events.clear();
               self.last_batch = Instant::now();
               Some(batch)
           } else {
               None
           }
       }
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- âœ… å¯ä»¥ç›‘æ§æŒ‡å®šç›®å½•çš„æ–‡ä»¶å˜åŒ–
- âœ… äº‹ä»¶å¯ä»¥æ­£ç¡®æ•è·
- âœ… æ”¯æŒé€’å½’ç›‘æ§å­ç›®å½•
- âœ… äº‹ä»¶æ‰¹å¤„ç†æ­£å¸¸å·¥ä½œ

**å‚è€ƒæ–‡æ¡£**: `é¡¹ç›®éœ€æ±‚åˆ†æ.md` 3.1.2 - æ–‡ä»¶ç³»ç»Ÿç›‘æ§æ¨¡å—

---

#### Task 3.2: å¿½ç•¥è§„åˆ™å®ç° (Day 4-5)

**ç›®æ ‡**: å®ç°æ–‡ä»¶è¿‡æ»¤è§„åˆ™ï¼Œå¿½ç•¥ä¸´æ—¶æ–‡ä»¶ã€ç³»ç»Ÿæ–‡ä»¶

**å®æ–½æ­¥éª¤**:

1. **åˆ›å»º `src-tauri/src/ignore_filter.rs`**
   ```rust
   use glob::Pattern;
   use std::path::Path;
   
   pub struct IgnoreFilter {
       patterns: Vec<Pattern>,
   }
   
   impl IgnoreFilter {
       pub fn new(patterns: Vec<String>) -> Self {
           let compiled: Vec<Pattern> = patterns
               .iter()
               .filter_map(|p| Pattern::new(p).ok())
               .collect();
           
           Self { patterns: compiled }
       }
       
       pub fn should_ignore(&self, path: &Path) -> bool {
           let path_str = path.to_string_lossy();
           self.patterns.iter().any(|pattern| pattern.matches(&path_str))
       }
       
       pub fn default_patterns() -> Vec<String> {
           vec![
               ".DS_Store".to_string(),
               "Thumbs.db".to_string(),
               "*.tmp".to_string(),
               ".git/".to_string(),
               "node_modules/".to_string(),
               "*.log".to_string(),
           ]
       }
   }
   ```

2. **åœ¨æ–‡ä»¶ç›‘æ§ä¸­åº”ç”¨è¿‡æ»¤**
   ```rust
   impl FileWatcher {
       pub fn handle_event(&self, event: FileEvent, filter: &IgnoreFilter) -> Option<FileEvent> {
           if filter.should_ignore(&event.path) {
               return None;
           }
           Some(event)
       }
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- âœ… é»˜è®¤å¿½ç•¥è§„åˆ™ç”Ÿæ•ˆ
- âœ… ç”¨æˆ·è‡ªå®šä¹‰è§„åˆ™å¯ä»¥æ·»åŠ 
- âœ… æ”¯æŒ glob æ¨¡å¼åŒ¹é…

**å‚è€ƒæ–‡æ¡£**: `é¡¹ç›®éœ€æ±‚åˆ†æ.md` 3.1.2 - æ–‡ä»¶ç³»ç»Ÿç›‘æ§æ¨¡å—

---

#### Task 3.3: å‰ç«¯æ–‡ä»¶ç›‘æ§çŠ¶æ€æ˜¾ç¤º (Day 5-7)

**ç›®æ ‡**: åœ¨å‰ç«¯æ˜¾ç¤ºæ–‡ä»¶ç›‘æ§çŠ¶æ€å’Œäº‹ä»¶

**å®æ–½æ­¥éª¤**:

1. **åˆ›å»ºæ–‡ä»¶ç›‘æ§çŠ¶æ€ç»„ä»¶**
   ```jsx
   import { useAtom } from 'jotai';
   import { fileWatcherStatusAtom } from '../atoms/syncState';
   
   export default function FileWatcherStatus() {
       const [status] = useAtom(fileWatcherStatusAtom);
       
       return (
           <Card>
               <h3>æ–‡ä»¶ç›‘æ§çŠ¶æ€</h3>
               <p>ç›‘æ§ç›®å½•: {status.watchedDirs.length}</p>
               <p>æœ€è¿‘äº‹ä»¶: {status.recentEvents.length}</p>
           </Card>
       );
   }
   ```

2. **å®ç°äº‹ä»¶ç›‘å¬**
   ```rust
   #[tauri::command]
   async fn watch_folder(folder_id: String, local_path: String) -> Result<()> {
       // å¼€å§‹ç›‘æ§æ–‡ä»¶å¤¹
       // å‘é€äº‹ä»¶åˆ°å‰ç«¯
       Ok(())
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- âœ… ç›‘æ§çŠ¶æ€å¯ä»¥å®æ—¶æ˜¾ç¤º
- âœ… æ–‡ä»¶å˜æ›´äº‹ä»¶å¯ä»¥é€šçŸ¥å‰ç«¯
- âœ… UIæ›´æ–°ä¸å¡é¡¿

---

### ğŸ“Š Phase 3 äº¤ä»˜ç‰©æ£€æŸ¥æ¸…å•

- [ ] æ–‡ä»¶ç³»ç»Ÿç›‘æ§åŠŸèƒ½å®Œæˆ
- [ ] äº‹ä»¶æ‰¹å¤„ç†å®ç°
- [ ] å¿½ç•¥è§„åˆ™è¿‡æ»¤å®ç°
- [ ] å‰ç«¯çŠ¶æ€æ˜¾ç¤ºæ­£å¸¸

---

## ğŸ“… Phase 4: æ ¸å¿ƒåŒæ­¥å¼•æ“ (Week 4)

### ğŸ¯ é˜¶æ®µç›®æ ‡
- å®ç°æ–‡ä»¶æ‰«æå’Œå¯¹æ¯”
- å®ç°åŒæ­¥å†³ç­–ç®—æ³•
- å®ç°å†²çªæ£€æµ‹å’Œè§£å†³
- å®ç°æ–‡ä»¶ä¸Šä¼ ä¸‹è½½

### ğŸ“ è¯¦ç»†ä»»åŠ¡æ¸…å•

#### Task 4.1: SQLite æ•°æ®åº“é›†æˆ (Day 1)

**ç›®æ ‡**: å°†æ–‡ä»¶å…ƒæ•°æ®å­˜å‚¨åˆ° SQLite æ•°æ®åº“

**å®æ–½æ­¥éª¤**:

1. **ä½¿ç”¨æ•°æ®åº“å­˜å‚¨æ–‡ä»¶å¿«ç…§**
   ```rust
   // src-tauri/src/snapshot.rs
   use crate::database;
   use crate::error::Result;
   
   pub async fn save_snapshot_to_db(
       app: &AppHandle,
       folder_id: &str,
       snapshot: &FileSnapshot,
   ) -> Result<()> {
       // æ‰¹é‡ä¿å­˜æ–‡ä»¶å…ƒæ•°æ®åˆ°æ•°æ®åº“
       for (path, metadata) in &snapshot.files {
           let relative_path = path.strip_prefix(&base_path)?
               .to_string_lossy()
               .to_string();
           
           let db_metadata = database::FileMetadata {
               id: None,
               folder_id: folder_id.to_string(),
               relative_path,
               file_type: if metadata.is_directory { "directory" } else { "file" }.to_string(),
               size: Some(metadata.size as i64),
               modified_time: Some(metadata.modified_time as i64),
               content_hash: Some(metadata.content_hash.clone()),
               etag: None,
               is_deleted: false,
               last_seen: Some(snapshot.timestamp as i64),
           };
           
           database::save_file_metadata(app, &db_metadata).await?;
       }
       
       Ok(())
   }
   
   pub async fn load_snapshot_from_db(
       app: &AppHandle,
       folder_id: &str,
   ) -> Result<FileSnapshot> {
       let db_files = database::get_all_files_in_folder(app, folder_id).await?;
       
       let mut files = HashMap::new();
       for db_file in db_files {
           if !db_file.is_deleted {
               let metadata = FileMetadata {
                   path: PathBuf::from(&db_file.relative_path),
                   size: db_file.size.unwrap_or(0) as u64,
                   modified_time: db_file.modified_time.unwrap_or(0) as u64,
                   content_hash: db_file.content_hash.unwrap_or_default(),
                   is_directory: db_file.file_type == "directory",
               };
               files.insert(PathBuf::from(&db_file.relative_path), metadata);
           }
       }
       
       Ok(FileSnapshot {
           files,
           timestamp: std::time::SystemTime::now()
               .duration_since(std::time::UNIX_EPOCH)?
               .as_secs(),
       })
   }
   ```

2. **å®ç°å¿«ç…§å¯¹æ¯”åŠŸèƒ½ï¼ˆä½¿ç”¨æ•°æ®åº“ï¼‰**
   ```rust
   pub async fn compare_snapshots(
       app: &AppHandle,
       folder_id: &str,
       current: &FileSnapshot,
   ) -> Result<Vec<FileChange>> {
       // ä»æ•°æ®åº“åŠ è½½å†å²å¿«ç…§
       let previous = load_snapshot_from_db(app, folder_id).await?;
       
       // å¯¹æ¯”å¿«ç…§
       let changes = detect_changes(current, &previous, None, None);
       
       // ä¿å­˜æ–°å¿«ç…§åˆ°æ•°æ®åº“
       save_snapshot_to_db(app, folder_id, current).await?;
       
       Ok(changes)
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- âœ… æ–‡ä»¶å…ƒæ•°æ®å¯ä»¥ä¿å­˜åˆ°æ•°æ®åº“
- âœ… å¯ä»¥ä»æ•°æ®åº“åŠ è½½å¿«ç…§
- âœ… å¿«ç…§å¯¹æ¯”åŠŸèƒ½æ­£å¸¸
- âœ… æ•°æ®åº“æŸ¥è¯¢æ€§èƒ½è‰¯å¥½

**å‚è€ƒæ–‡æ¡£**: `SQLiteä½¿ç”¨å¿…è¦æ€§åˆ†æ.md`

---

#### Task 4.2: æ–‡ä»¶æ‰«æä¸å¿«ç…§ (Day 2-3)

**ç›®æ ‡**: å®ç°æœ¬åœ°å’Œè¿œç¨‹æ–‡ä»¶æ‰«æï¼Œç”Ÿæˆæ–‡ä»¶å¿«ç…§

**å®æ–½æ­¥éª¤**:

1. **åˆ›å»ºæ–‡ä»¶å…ƒæ•°æ®ç»“æ„**
   ```rust
   #[derive(Debug, Clone, Serialize, Deserialize)]
   pub struct FileMetadata {
       pub path: PathBuf,
       pub size: u64,
       pub modified_time: u64,
       pub content_hash: String,
       pub is_directory: bool,
   }
   
   #[derive(Debug, Clone, Serialize, Deserialize)]
   pub struct FileSnapshot {
       pub files: HashMap<PathBuf, FileMetadata>,
       pub timestamp: u64,
   }
   ```

2. **å®ç°æœ¬åœ°æ–‡ä»¶æ‰«æ**
   ```rust
   use walkdir::WalkDir;
   
   pub fn scan_local_directory(path: &Path) -> Result<FileSnapshot> {
       let mut files = HashMap::new();
       
       for entry in WalkDir::new(path) {
           let entry = entry?;
           let metadata = entry.metadata()?;
           
           let file_meta = FileMetadata {
               path: entry.path().to_path_buf(),
               size: metadata.len(),
               modified_time: metadata.modified()?
                   .duration_since(std::time::UNIX_EPOCH)?
                   .as_secs(),
               content_hash: calculate_hash(entry.path())?,
               is_directory: metadata.is_dir(),
           };
           
           files.insert(entry.path().to_path_buf(), file_meta);
       }
       
       Ok(FileSnapshot {
           files,
           timestamp: std::time::SystemTime::now()
               .duration_since(std::time::UNIX_EPOCH)?
               .as_secs(),
       })
   }
   ```

3. **å®ç°è¿œç¨‹æ–‡ä»¶æ‰«æ**
   ```rust
   pub async fn scan_remote_directory(
       client: &WebDavClient,
       path: &str,
   ) -> Result<FileSnapshot> {
       let file_list = client.list(path, Depth::Number(999)).await?;
       // è½¬æ¢ä¸º FileSnapshot
       Ok(FileSnapshot { /* ... */ })
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- âœ… å¯ä»¥æ‰«ææœ¬åœ°ç›®å½•æ ‘
- âœ… å¯ä»¥æ‰«æè¿œç¨‹ç›®å½•æ ‘
- âœ… æ–‡ä»¶å…ƒæ•°æ®æ­£ç¡®æå–
- âœ… å¿«ç…§å¯ä»¥åºåˆ—åŒ–å­˜å‚¨

**å‚è€ƒæ–‡æ¡£**: `é¡¹ç›®éœ€æ±‚åˆ†æ.md` UC-003 - æ‰§è¡Œæ–‡ä»¶åŒæ­¥

---

#### Task 4.2: å˜æ›´æ£€æµ‹ç®—æ³• (Day 3-5)

**ç›®æ ‡**: å¯¹æ¯”å¿«ç…§ï¼Œæ£€æµ‹æ–‡ä»¶å˜æ›´

**å®æ–½æ­¥éª¤**:

1. **åˆ›å»ºå˜æ›´æ£€æµ‹æ¨¡å—**
   ```rust
   #[derive(Debug, Clone)]
   pub enum ChangeType {
       Created,
       Modified,
       Deleted,
       Unchanged,
   }
   
   #[derive(Debug, Clone)]
   pub struct FileChange {
       pub path: PathBuf,
       pub change_type: ChangeType,
       pub local_meta: Option<FileMetadata>,
       pub remote_meta: Option<FileMetadata>,
   }
   
   pub fn detect_changes(
       local_snapshot: &FileSnapshot,
       remote_snapshot: &FileSnapshot,
       previous_local: Option<&FileSnapshot>,
       previous_remote: Option<&FileSnapshot>,
   ) -> Vec<FileChange> {
       let mut changes = Vec::new();
       
       // æ£€æµ‹æ–°å¢æ–‡ä»¶
       for (path, meta) in &local_snapshot.files {
           if !remote_snapshot.files.contains_key(path) {
               changes.push(FileChange {
                   path: path.clone(),
                   change_type: ChangeType::Created,
                   local_meta: Some(meta.clone()),
                   remote_meta: None,
               });
           }
       }
       
       // æ£€æµ‹ä¿®æ”¹æ–‡ä»¶
       for (path, local_meta) in &local_snapshot.files {
           if let Some(remote_meta) = remote_snapshot.files.get(path) {
               if local_meta.content_hash != remote_meta.content_hash {
                   changes.push(FileChange {
                       path: path.clone(),
                       change_type: ChangeType::Modified,
                       local_meta: Some(local_meta.clone()),
                       remote_meta: Some(remote_meta.clone()),
                   });
               }
           }
       }
       
       // æ£€æµ‹åˆ é™¤æ–‡ä»¶
       for (path, remote_meta) in &remote_snapshot.files {
           if !local_snapshot.files.contains_key(path) {
               changes.push(FileChange {
                   path: path.clone(),
                   change_type: ChangeType::Deleted,
                   local_meta: None,
                   remote_meta: Some(remote_meta.clone()),
               });
           }
       }
       
       changes
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- âœ… å¯ä»¥æ­£ç¡®æ£€æµ‹æ–°å¢ã€ä¿®æ”¹ã€åˆ é™¤
- âœ… åŸºäºå†…å®¹å“ˆå¸Œåˆ¤æ–­å˜æ›´
- âœ… å˜æ›´åˆ—è¡¨å®Œæ•´å‡†ç¡®

**å‚è€ƒæ–‡æ¡£**: `é¡¹ç›®éœ€æ±‚åˆ†æ.md` UC-003 - æ‰§è¡Œæ–‡ä»¶åŒæ­¥ï¼ˆè¯¦ç»†åŒæ­¥ç®—æ³•ï¼‰

---

#### Task 4.3: å†²çªæ£€æµ‹ä¸è§£å†³ (Day 5-6)

**ç›®æ ‡**: å®ç°å†²çªæ£€æµ‹å’Œè§£å†³ç­–ç•¥

**å®æ–½æ­¥éª¤**:

1. **å®ç°å†²çªæ£€æµ‹**
   ```rust
   #[derive(Debug, Clone)]
   pub enum ConflictType {
       BothModified,      // æœ¬åœ°å’Œè¿œç¨‹éƒ½ä¿®æ”¹
       LocalModifiedRemoteDeleted,  // æœ¬åœ°ä¿®æ”¹ï¼Œè¿œç¨‹åˆ é™¤
       LocalDeletedRemoteModified,  // æœ¬åœ°åˆ é™¤ï¼Œè¿œç¨‹ä¿®æ”¹
   }
   
   pub fn detect_conflicts(changes: &[FileChange]) -> Vec<Conflict> {
       let mut conflicts = Vec::new();
       
       for change in changes {
           if let Some(conflict_type) = check_conflict(change) {
               conflicts.push(Conflict {
                   path: change.path.clone(),
                   conflict_type,
                   local_meta: change.local_meta.clone(),
                   remote_meta: change.remote_meta.clone(),
               });
           }
       }
       
       conflicts
   }
   ```

2. **å®ç°è§£å†³ç­–ç•¥**
   ```rust
   #[derive(Debug, Clone)]
   pub enum ConflictResolution {
       AskUser,
       LocalWins,
       RemoteWins,
       KeepBoth,
   }
   
   pub async fn resolve_conflict(
       conflict: &Conflict,
       resolution: ConflictResolution,
       client: &WebDavClient,
   ) -> Result<()> {
       match resolution {
           ConflictResolution::LocalWins => {
               // ä¸Šä¼ æœ¬åœ°æ–‡ä»¶
               client.upload(&conflict.path, &remote_path).await?;
           }
           ConflictResolution::RemoteWins => {
               // ä¸‹è½½è¿œç¨‹æ–‡ä»¶
               client.download(&remote_path, &conflict.path).await?;
           }
           ConflictResolution::KeepBoth => {
               // ä¸‹è½½ä¸º .conflict åç¼€
               let conflict_path = conflict.path.with_extension("conflict");
               client.download(&remote_path, &conflict_path).await?;
           }
           ConflictResolution::AskUser => {
               // å‘é€äº‹ä»¶åˆ°å‰ç«¯ï¼Œç­‰å¾…ç”¨æˆ·é€‰æ‹©
               // å®ç°è§å‰ç«¯éƒ¨åˆ†
           }
       }
       Ok(())
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- âœ… å†²çªå¯ä»¥æ­£ç¡®æ£€æµ‹
- âœ… æ‰€æœ‰å†²çªç±»å‹éƒ½èƒ½è¯†åˆ«
- âœ… è§£å†³ç­–ç•¥æ­£ç¡®æ‰§è¡Œ

**å‚è€ƒæ–‡æ¡£**: `é¡¹ç›®éœ€æ±‚åˆ†æ.md` UC-003 - å†²çªæ£€æµ‹é€»è¾‘

---

#### Task 4.4: åŒæ­¥æ‰§è¡Œå¼•æ“ (Day 6-7)

**ç›®æ ‡**: å®ç°å®Œæ•´çš„åŒæ­¥æ‰§è¡Œæµç¨‹

**å®æ–½æ­¥éª¤**:

1. **åˆ›å»ºåŒæ­¥å¼•æ“**
   ```rust
   pub struct SyncEngine {
       client: WebDavClient,
       local_path: PathBuf,
       remote_path: String,
       conflict_resolution: ConflictResolution,
   }
   
   impl SyncEngine {
       pub async fn sync(&self) -> Result<SyncResult> {
           // 1. æ‰«ææ–‡ä»¶
           let local_snapshot = scan_local_directory(&self.local_path)?;
           let remote_snapshot = scan_remote_directory(&self.client, &self.remote_path).await?;
           
           // 2. åŠ è½½å†å²å¿«ç…§
           let previous_local = load_snapshot("local").ok();
           let previous_remote = load_snapshot("remote").ok();
           
           // 3. æ£€æµ‹å˜æ›´
           let changes = detect_changes(
               &local_snapshot,
               &remote_snapshot,
               previous_local.as_ref(),
               previous_remote.as_ref(),
           );
           
           // 4. æ£€æµ‹å†²çª
           let conflicts = detect_conflicts(&changes);
           
           // 5. è§£å†³å†²çª
           for conflict in &conflicts {
               self.resolve_conflict(conflict, self.conflict_resolution.clone()).await?;
           }
           
           // 6. æ‰§è¡ŒåŒæ­¥æ“ä½œ
           for change in &changes {
               if !conflicts.iter().any(|c| c.path == change.path) {
                   self.apply_change(change).await?;
               }
           }
           
           // 7. ä¿å­˜å¿«ç…§
           save_snapshot("local", &local_snapshot)?;
           save_snapshot("remote", &remote_snapshot)?;
           
           Ok(SyncResult {
               files_uploaded: 0,
               files_downloaded: 0,
               conflicts_resolved: conflicts.len(),
           })
       }
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- âœ… å®Œæ•´åŒæ­¥æµç¨‹å¯ä»¥æ‰§è¡Œ
- âœ… æ”¯æŒä¸Šä¼ ã€ä¸‹è½½ã€åˆ é™¤æ“ä½œ
- âœ… å†²çªæ­£ç¡®å¤„ç†
- âœ… åŒæ­¥ç»“æœæ­£ç¡®è¿”å›

**å‚è€ƒæ–‡æ¡£**: `é¡¹ç›®éœ€æ±‚åˆ†æ.md` UC-003 - æ‰§è¡Œæ–‡ä»¶åŒæ­¥

---

### ğŸ“Š Phase 4 äº¤ä»˜ç‰©æ£€æŸ¥æ¸…å•

- [ ] æ–‡ä»¶æ‰«æåŠŸèƒ½å®Œæˆ
- [ ] å˜æ›´æ£€æµ‹ç®—æ³•å®ç°
- [ ] å†²çªæ£€æµ‹å’Œè§£å†³å®ç°
- [ ] åŒæ­¥æ‰§è¡Œå¼•æ“å®Œæˆ
- [ ] å¯ä»¥æ‰§è¡Œå®Œæ•´çš„åŒå‘åŒæ­¥

---

## ğŸ“… Phase 5: åŒæ­¥æ–‡ä»¶å¤¹é…ç½® (Week 5)

### ğŸ¯ é˜¶æ®µç›®æ ‡
- å®ç°åŒæ­¥æ–‡ä»¶å¤¹é…ç½®ç•Œé¢
- å®ç°åŒæ­¥ç­–ç•¥è®¾ç½®
- å®ç°æ–‡ä»¶å¤¹ç®¡ç†åŠŸèƒ½

### ğŸ“ è¯¦ç»†ä»»åŠ¡æ¸…å•

#### Task 5.1: åŒæ­¥æ–‡ä»¶å¤¹é…ç½®ç•Œé¢ (Day 1-4)

**ç›®æ ‡**: å®ç°æ·»åŠ ã€ç¼–è¾‘åŒæ­¥æ–‡ä»¶å¤¹çš„ç•Œé¢

**å®æ–½æ­¥éª¤**:

1. **åˆ›å»ºåŒæ­¥æ–‡ä»¶å¤¹é…ç½®è¡¨å•**
   ```jsx
   import { Input, Select, Checkbox, Card } from '@nextui-org/react';
   
   export default function SyncFolderForm({ folder, onSave }) {
       const [config, setConfig] = useState({
           local_path: folder?.local_path || '',
           remote_path: folder?.remote_path || '',
           sync_direction: folder?.sync_direction || 'both',
           sync_interval_minutes: folder?.sync_interval_minutes || 15,
           conflict_resolution: folder?.conflict_resolution || 'ask_user',
           ignore_patterns: folder?.ignore_patterns || [],
       });
       
       return (
           <Card className="p-4">
               <Input
                   label="æœ¬åœ°è·¯å¾„"
                   value={config.local_path}
                   readOnly
                   endContent={<Button onClick={selectFolder}>é€‰æ‹©</Button>}
               />
               <Input
                   label="è¿œç¨‹è·¯å¾„"
                   value={config.remote_path}
                   onChange={(e) => setConfig({...config, remote_path: e.target.value})}
               />
               <Select
                   label="åŒæ­¥æ–¹å‘"
                   selectedKeys={[config.sync_direction]}
                   onSelectionChange={(keys) => {
                       setConfig({...config, sync_direction: Array.from(keys)[0]});
                   }}
               >
                   <SelectItem key="both">åŒå‘åŒæ­¥</SelectItem>
                   <SelectItem key="upload">ä»…ä¸Šä¼ </SelectItem>
                   <SelectItem key="download">ä»…ä¸‹è½½</SelectItem>
               </Select>
               {/* å…¶ä»–é…ç½®é¡¹ */}
           </Card>
       );
   }
   ```

2. **å®ç°æ–‡ä»¶å¤¹é€‰æ‹©å™¨**
   ```rust
   #[tauri::command]
   async fn select_folder() -> Result<Option<String>, String> {
       use tauri::api::dialog::blocking::FileDialogBuilder;
       
       let path = FileDialogBuilder::new()
           .set_title("é€‰æ‹©è¦åŒæ­¥çš„æ–‡ä»¶å¤¹")
           .pick_folder();
       
       Ok(path.map(|p| p.to_string_lossy().to_string()))
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- âœ… å¯ä»¥æ·»åŠ åŒæ­¥æ–‡ä»¶å¤¹
- âœ… å¯ä»¥ç¼–è¾‘åŒæ­¥é…ç½®
- âœ… è¡¨å•éªŒè¯å®Œæ•´
- âœ… è·¯å¾„é€‰æ‹©å™¨æ­£å¸¸å·¥ä½œ

**å‚è€ƒæ–‡æ¡£**: `é¡¹ç›®éœ€æ±‚åˆ†æ.md` UC-002 - é…ç½®åŒæ­¥æ–‡ä»¶å¤¹

---

#### Task 5.2: åŒæ­¥ç­–ç•¥é…ç½® (Day 4-6)

**ç›®æ ‡**: å®ç°åŒæ­¥é¢‘ç‡ã€å†²çªå¤„ç†ç­‰ç­–ç•¥é…ç½®

**å®æ–½æ­¥éª¤**:

1. **å®ç°åŒæ­¥é¢‘ç‡é…ç½®**
   ```jsx
   <Select
       label="åŒæ­¥é¢‘ç‡"
       selectedKeys={[config.sync_interval_minutes.toString()]}
   >
       <SelectItem key="0">å®æ—¶ç›‘æ§</SelectItem>
       <SelectItem key="1">æ¯åˆ†é’Ÿ</SelectItem>
       <SelectItem key="5">æ¯5åˆ†é’Ÿ</SelectItem>
       <SelectItem key="15">æ¯15åˆ†é’Ÿ</SelectItem>
       <SelectItem key="60">æ¯å°æ—¶</SelectItem>
       <SelectItem key="-1">ä»…æ‰‹åŠ¨</SelectItem>
   </Select>
   ```

2. **å®ç°å¿½ç•¥è§„åˆ™é…ç½®**
   ```jsx
   <div>
       <h4>å¿½ç•¥è§„åˆ™</h4>
       <Input
           placeholder="ä¾‹å¦‚: *.tmp, .git/"
           value={newPattern}
           onChange={(e) => setNewPattern(e.target.value)}
       />
       <Button onClick={addPattern}>æ·»åŠ </Button>
       <div>
           {config.ignore_patterns.map((pattern, idx) => (
               <Chip
                   key={idx}
                   onClose={() => removePattern(idx)}
               >
                   {pattern}
               </Chip>
           ))}
       </div>
   </div>
   ```

**éªŒæ”¶æ ‡å‡†**:
- âœ… åŒæ­¥é¢‘ç‡å¯ä»¥é…ç½®
- âœ… å†²çªå¤„ç†ç­–ç•¥å¯ä»¥è®¾ç½®
- âœ… å¿½ç•¥è§„åˆ™å¯ä»¥æ·»åŠ å’Œåˆ é™¤

---

#### Task 5.3: æ–‡ä»¶å¤¹åˆ—è¡¨ç®¡ç† (Day 6-7)

**ç›®æ ‡**: å®ç°åŒæ­¥æ–‡ä»¶å¤¹åˆ—è¡¨æ˜¾ç¤ºå’Œç®¡ç†

**å®æ–½æ­¥éª¤**:

1. **åˆ›å»ºæ–‡ä»¶å¤¹åˆ—è¡¨ç»„ä»¶**
   ```jsx
   import { Table, TableHeader, TableColumn, TableBody, TableRow, TableCell } from '@nextui-org/react';
   
   export default function SyncFolderList({ folders, onEdit, onDelete, onSync }) {
       return (
           <Table>
               <TableHeader>
                   <TableColumn>æœ¬åœ°è·¯å¾„</TableColumn>
                   <TableColumn>è¿œç¨‹è·¯å¾„</TableColumn>
                   <TableColumn>åŒæ­¥æ–¹å‘</TableColumn>
                   <TableColumn>æœ€ååŒæ­¥</TableColumn>
                   <TableColumn>çŠ¶æ€</TableColumn>
                   <TableColumn>æ“ä½œ</TableColumn>
               </TableHeader>
               <TableBody>
                   {folders.map((folder) => (
                       <TableRow key={folder.id}>
                           <TableCell>{folder.local_path}</TableCell>
                           <TableCell>{folder.remote_path}</TableCell>
                           <TableCell>{folder.sync_direction}</TableCell>
                           <TableCell>{formatTime(folder.last_sync)}</TableCell>
                           <TableCell>
                               <Chip color={getStatusColor(folder.status)}>
                                   {folder.status}
                               </Chip>
                           </TableCell>
                           <TableCell>
                               <Button size="sm" onClick={() => onSync(folder.id)}>
                                   ç«‹å³åŒæ­¥
                               </Button>
                               <Button size="sm" onClick={() => onEdit(folder)}>
                                   ç¼–è¾‘
                               </Button>
                               <Button size="sm" color="danger" onClick={() => onDelete(folder.id)}>
                                   åˆ é™¤
                               </Button>
                           </TableCell>
                       </TableRow>
                   ))}
               </TableBody>
           </Table>
       );
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- âœ… æ–‡ä»¶å¤¹åˆ—è¡¨æ­£ç¡®æ˜¾ç¤º
- âœ… æ”¯æŒç¼–è¾‘ã€åˆ é™¤æ“ä½œ
- âœ… æ”¯æŒç«‹å³åŒæ­¥æ“ä½œ
- âœ… çŠ¶æ€å®æ—¶æ›´æ–°

---

### ğŸ“Š Phase 5 äº¤ä»˜ç‰©æ£€æŸ¥æ¸…å•

- [ ] åŒæ­¥æ–‡ä»¶å¤¹é…ç½®ç•Œé¢å®Œæˆ
- [ ] åŒæ­¥ç­–ç•¥é…ç½®åŠŸèƒ½å®Œæˆ
- [ ] æ–‡ä»¶å¤¹åˆ—è¡¨ç®¡ç†å®Œæˆ
- [ ] æ”¯æŒæ‰€æœ‰é…ç½®é€‰é¡¹

---

## ğŸ“… Phase 6: å®šæ—¶ä»»åŠ¡ä¸è°ƒåº¦ (Week 6)

### ğŸ¯ é˜¶æ®µç›®æ ‡
- å®ç°å®šæ—¶ä»»åŠ¡è°ƒåº¦å™¨
- å®ç°æ™ºèƒ½è°ƒåº¦ç®—æ³•
- å®ç°åå°è¿è¡ŒåŠŸèƒ½

### ğŸ“ è¯¦ç»†ä»»åŠ¡æ¸…å•

#### Task 6.1: ä»»åŠ¡è°ƒåº¦å™¨å®ç° (Day 1-4)

**ç›®æ ‡**: å®ç°åŸºäºæ—¶é—´é—´éš”çš„ä»»åŠ¡è°ƒåº¦

**å®æ–½æ­¥éª¤**:

1. **åˆ›å»ºè°ƒåº¦å™¨æ¨¡å—**
   ```rust
   use tokio::time::{interval, Duration};
   use std::collections::HashMap;
   
   pub struct TaskScheduler {
       folders: HashMap<String, SyncFolderConfig>,
       last_sync_times: HashMap<String, Instant>,
   }
   
   impl TaskScheduler {
       pub fn new() -> Self {
           Self {
               folders: HashMap::new(),
               last_sync_times: HashMap::new(),
           }
       }
       
       pub async fn start(&mut self) {
           let mut ticker = interval(Duration::from_secs(60));
           
           loop {
               ticker.tick().await;
               
               for (folder_id, folder) in &self.folders {
                   if self.should_sync_now(folder_id, folder) {
                       self.trigger_sync(folder_id).await;
                   }
               }
           }
       }
       
       fn should_sync_now(&self, folder_id: &str, folder: &SyncFolderConfig) -> bool {
           if folder.sync_interval_minutes < 0 {
               return false; // ä»…æ‰‹åŠ¨
           }
           
           let last_sync = self.last_sync_times
               .get(folder_id)
               .unwrap_or(&Instant::now());
           
           let interval = Duration::from_secs(folder.sync_interval_minutes as u64 * 60);
           last_sync.elapsed() >= interval
       }
       
       async fn trigger_sync(&mut self, folder_id: &str) {
           // è§¦å‘åŒæ­¥ä»»åŠ¡
           self.last_sync_times.insert(folder_id.to_string(), Instant::now());
       }
   }
   ```

2. **å®ç°å®æ—¶ç›‘æ§æ¨¡å¼**
   ```rust
   pub async fn start_realtime_watch(folder_id: String, local_path: PathBuf) {
       let (mut watcher, mut rx) = FileWatcher::new();
       watcher.watch_directory(local_path.clone()).unwrap();
       
       let mut batcher = EventBatcher::new(Duration::from_millis(500));
       
       while let Ok(event) = rx.recv() {
           if let Some(batch) = batcher.add_event(event) {
               if batch.is_significant() {
                   trigger_sync(folder_id.clone()).await;
               }
           }
       }
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- âœ… å®šæ—¶ä»»åŠ¡å¯ä»¥æŒ‰é…ç½®æ‰§è¡Œ
- âœ… å®æ—¶ç›‘æ§æ¨¡å¼æ­£å¸¸å·¥ä½œ
- âœ… è°ƒåº¦å™¨ä¸é˜»å¡ä¸»çº¿ç¨‹
- âœ… èµ„æºæ¶ˆè€—æ§åˆ¶åœ¨è¦æ±‚èŒƒå›´å†…

**å‚è€ƒæ–‡æ¡£**: `é¡¹ç›®éœ€æ±‚åˆ†æ.md` UC-004 - å®šæ—¶ä»»åŠ¡è°ƒåº¦

---

#### Task 6.2: æ™ºèƒ½è°ƒåº¦ç®—æ³• (Day 4-6)

**ç›®æ ‡**: å®ç°åŸºäºå†å²æ•°æ®çš„æ™ºèƒ½è°ƒåº¦

**å®æ–½æ­¥éª¤**:

1. **å®ç°å˜æ›´é¢‘ç‡è®¡ç®—**
   ```rust
   pub struct SmartScheduler {
       change_frequency: HashMap<String, f64>,
       history: Vec<SyncHistory>,
   }
   
   impl SmartScheduler {
       fn calculate_sync_frequency(&self, folder_id: &str) -> f64 {
           // åˆ†æå†å²åŒæ­¥æ•°æ®
           // è®¡ç®—æ¯å°æ—¶çš„å¹³å‡å˜æ›´æ¬¡æ•°
           let recent_history: Vec<_> = self.history
               .iter()
               .filter(|h| h.folder_id == folder_id)
               .filter(|h| h.timestamp > get_24h_ago())
               .collect();
           
           let change_count: u64 = recent_history.iter()
               .map(|h| h.files_changed)
               .sum();
           
           change_count as f64 / 24.0 // æ¯å°æ—¶å˜æ›´æ¬¡æ•°
       }
       
       fn optimal_interval_for_frequency(&self, frequency: f64) -> Duration {
           // æ ¹æ®å˜æ›´é¢‘ç‡è®¡ç®—æœ€ä¼˜é—´éš”
           if frequency > 10.0 {
               Duration::from_secs(60) // é«˜é¢‘ï¼šæ¯åˆ†é’Ÿ
           } else if frequency > 1.0 {
               Duration::from_secs(300) // ä¸­é¢‘ï¼šæ¯5åˆ†é’Ÿ
           } else {
               Duration::from_secs(3600) // ä½é¢‘ï¼šæ¯å°æ—¶
           }
       }
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- âœ… å¯ä»¥æ ¹æ®å†å²æ•°æ®è°ƒæ•´è°ƒåº¦é—´éš”
- âœ… æ™ºèƒ½è°ƒåº¦ç®—æ³•æ­£å¸¸å·¥ä½œ
- âœ… èµ„æºæ¶ˆè€—ä¼˜åŒ–æ˜æ˜¾

---

#### Task 6.3: ç³»ç»Ÿæ‰˜ç›˜é›†æˆ (Day 6-7)

**ç›®æ ‡**: å®ç°ç³»ç»Ÿæ‰˜ç›˜åŠŸèƒ½ï¼Œæ”¯æŒåå°è¿è¡Œ

**å®æ–½æ­¥éª¤**:

1. **åˆ›å»ºæ‰˜ç›˜èœå•**
   ```rust
   use tauri::{CustomMenuItem, SystemTray, SystemTrayMenu, SystemTrayMenuItem};
   
   pub fn create_tray_menu() -> SystemTray {
       let quit = CustomMenuItem::new("quit".to_string(), "é€€å‡º");
       let show = CustomMenuItem::new("show".to_string(), "æ˜¾ç¤ºçª—å£");
       let sync_all = CustomMenuItem::new("sync_all".to_string(), "ç«‹å³å…¨éƒ¨åŒæ­¥");
       
       let menu = SystemTrayMenu::new()
           .add_item(show)
           .add_item(sync_all)
           .add_native_item(SystemTrayMenuItem::Separator)
           .add_item(quit);
       
       SystemTray::new().with_menu(menu)
   }
   ```

2. **å¤„ç†æ‰˜ç›˜äº‹ä»¶**
   ```rust
   pub fn tray_event_handler(app: &AppHandle, event: SystemTrayEvent) {
       match event {
           SystemTrayEvent::MenuItemClick { id, .. } => {
               match id.as_str() {
                   "quit" => {
                       app.exit(0);
                   }
                   "show" => {
                       if let Some(window) = app.get_window("main") {
                           window.show().unwrap();
                           window.set_focus().unwrap();
                       }
                   }
                   "sync_all" => {
                       trigger_sync_all().await;
                   }
                   _ => {}
               }
           }
           _ => {}
       }
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- âœ… ç³»ç»Ÿæ‰˜ç›˜æ­£å¸¸æ˜¾ç¤º
- âœ… æ‰˜ç›˜èœå•åŠŸèƒ½æ­£å¸¸
- âœ… æ”¯æŒæœ€å°åŒ–åˆ°æ‰˜ç›˜
- âœ… æ”¯æŒå¤šè¯­è¨€æ‰˜ç›˜èœå•

**å‚è€ƒæ–‡æ¡£**: `å¯ç”¨å­¦ä¹ å†…å®¹.md` ç¬¬7èŠ‚ - ç³»ç»Ÿé›†æˆ

---

### ğŸ“Š Phase 6 äº¤ä»˜ç‰©æ£€æŸ¥æ¸…å•

- [ ] å®šæ—¶ä»»åŠ¡è°ƒåº¦å™¨å®Œæˆ
- [ ] å®æ—¶ç›‘æ§æ¨¡å¼å®ç°
- [ ] æ™ºèƒ½è°ƒåº¦ç®—æ³•å®ç°
- [ ] ç³»ç»Ÿæ‰˜ç›˜åŠŸèƒ½å®Œæˆ
- [ ] åå°è¿è¡ŒåŠŸèƒ½æ­£å¸¸

---

## ğŸ“… Phase 7: ç”¨æˆ·ç•Œé¢å®Œå–„ (Week 7)

### ğŸ¯ é˜¶æ®µç›®æ ‡
- å®Œå–„ä¸»ç•Œé¢UI
- å®ç°åŒæ­¥çŠ¶æ€å®æ—¶æ˜¾ç¤º
- å®ç°åŒæ­¥æ—¥å¿—æŸ¥çœ‹
- ä¼˜åŒ–ç”¨æˆ·ä½“éªŒ

### ğŸ“ è¯¦ç»†ä»»åŠ¡æ¸…å•

#### Task 7.1: ä¸»ç•Œé¢å®Œå–„ (Day 1-3)

**ç›®æ ‡**: å®ç°å®Œæ•´çš„ä¸»ç•Œé¢å¸ƒå±€å’ŒåŠŸèƒ½

**å®æ–½æ­¥éª¤**:

1. **å®ç°åŒæ­¥çŠ¶æ€æ€»è§ˆ**
   ```jsx
   import { Card, Progress } from '@nextui-org/react';
   import { useAtomValue } from 'jotai';
   import { syncStatusAtom } from '../atoms/syncState';
   
   export default function SyncOverview() {
       const status = useAtomValue(syncStatusAtom);
       
       return (
           <Card className="p-4">
               <h2>åŒæ­¥çŠ¶æ€æ€»è§ˆ</h2>
               <div>
                   <p>æœ€ååŒæ­¥: {formatTime(status.lastSyncTime)}</p>
                   <p>æ´»è·ƒä»»åŠ¡: {status.activeTasks} ä¸ªæ–‡ä»¶å¤¹æ­£åœ¨åŒæ­¥</p>
                   <p>ä»Šæ—¥ç»Ÿè®¡: ä¸Šä¼  {status.todayUploaded} ä¸ªæ–‡ä»¶ ({formatSize(status.todayUploadedSize)})</p>
                   <p>é”™è¯¯æ•°é‡: {status.errorCount} ä¸ª</p>
               </div>
           </Card>
       );
   }
   ```

2. **å®ç°åŒæ­¥æ–‡ä»¶å¤¹åˆ—è¡¨**
   ```jsx
   export default function SyncFolderList({ folders }) {
       return (
           <div>
               <h2>åŒæ­¥æ–‡ä»¶å¤¹åˆ—è¡¨</h2>
               {folders.map((folder) => (
                   <Card key={folder.id} className="mb-2">
                       <div className="flex justify-between">
                           <div>
                               <p>{folder.local_path} â†’ {folder.remote_path}</p>
                               <p>æœ€ååŒæ­¥: {formatTime(folder.last_sync)}</p>
                               {folder.syncing && (
                                   <Progress value={folder.progress} />
                               )}
                           </div>
                           <div>
                               <Button onClick={() => syncFolder(folder.id)}>
                                   ç«‹å³åŒæ­¥
                               </Button>
                           </div>
                       </div>
                   </Card>
               ))}
           </div>
       );
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- âœ… ä¸»ç•Œé¢å¸ƒå±€å®Œæ•´
- âœ… çŠ¶æ€ä¿¡æ¯å®æ—¶æ›´æ–°
- âœ… äº¤äº’æµç•…ï¼Œæ— å¡é¡¿

**å‚è€ƒæ–‡æ¡£**: `é¡¹ç›®éœ€æ±‚åˆ†æ.md` UC-005 - ç”¨æˆ·ç•Œé¢äº¤äº’

---

#### Task 7.2: åŒæ­¥è¿›åº¦æ˜¾ç¤º (Day 3-5)

**ç›®æ ‡**: å®ç°åŒæ­¥è¿›åº¦å®æ—¶æ˜¾ç¤º

**å®æ–½æ­¥éª¤**:

1. **å®ç°è¿›åº¦çŠ¶æ€ç®¡ç†**
   ```rust
   #[derive(Debug, Clone, Serialize, Deserialize)]
   pub struct SyncProgress {
       pub folder_id: String,
       pub total_files: usize,
       pub processed_files: usize,
       pub current_file: String,
       pub bytes_transferred: u64,
       pub total_bytes: u64,
   }
   
   #[tauri::command]
   async fn get_sync_progress(folder_id: String) -> Result<SyncProgress, String> {
       // ä»å…¨å±€çŠ¶æ€è·å–è¿›åº¦
       Ok(get_progress(&folder_id))
   }
   ```

2. **å‰ç«¯è¿›åº¦æ˜¾ç¤º**
   ```jsx
   import { useAtom } from 'jotai';
   import { syncProgressAtom } from '../atoms/syncState';
   
   export default function SyncProgress({ folderId }) {
       const [progress] = useAtom(syncProgressAtom(folderId));
       
       return (
           <div>
               <Progress value={progress.percent} />
               <p>{progress.currentFile}</p>
               <p>{progress.processedFiles} / {progress.totalFiles}</p>
           </div>
       );
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- âœ… è¿›åº¦å¯ä»¥å®æ—¶æ˜¾ç¤º
- âœ… å½“å‰æ–‡ä»¶ä¿¡æ¯æ˜¾ç¤º
- âœ… ä¼ è¾“é€Ÿåº¦æ˜¾ç¤º

---

#### Task 7.3: åŒæ­¥æ—¥å¿—åŠŸèƒ½ (Day 5-7)

**ç›®æ ‡**: å®ç°åŒæ­¥æ—¥å¿—æŸ¥çœ‹å’Œç®¡ç†

**å®æ–½æ­¥éª¤**:

1. **å®ç°æ—¥å¿—å­˜å‚¨**
   ```rust
   use tauri_plugin_sql::TauriSql;
   
   #[derive(Debug, Serialize, Deserialize)]
   pub struct SyncLog {
       pub id: i64,
       pub folder_id: String,
       pub operation_type: String,
       pub file_path: String,
       pub status: String,
       pub error_message: Option<String>,
       pub timestamp: i64,
   }
   
   #[tauri::command]
   async fn get_sync_logs(folder_id: Option<String>, limit: i64) -> Result<Vec<SyncLog>, String> {
       // ä»æ•°æ®åº“æŸ¥è¯¢æ—¥å¿—
       Ok(vec![])
   }
   ```

2. **å®ç°æ—¥å¿—ç•Œé¢**
   ```jsx
   export default function SyncLogs({ folderId }) {
       const [logs, setLogs] = useState([]);
       
       useEffect(() => {
           loadLogs();
       }, [folderId]);
       
       return (
           <Table>
               <TableHeader>
                   <TableColumn>æ—¶é—´</TableColumn>
                   <TableColumn>æ“ä½œ</TableColumn>
                   <TableColumn>æ–‡ä»¶</TableColumn>
                   <TableColumn>çŠ¶æ€</TableColumn>
               </TableHeader>
               <TableBody>
                   {logs.map((log) => (
                       <TableRow key={log.id}>
                           <TableCell>{formatTime(log.timestamp)}</TableCell>
                           <TableCell>{log.operation_type}</TableCell>
                           <TableCell>{log.file_path}</TableCell>
                           <TableCell>
                               <Chip color={log.status === 'success' ? 'success' : 'danger'}>
                                   {log.status}
                               </Chip>
                           </TableCell>
                       </TableRow>
                   ))}
               </TableBody>
           </Table>
       );
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- âœ… æ—¥å¿—å¯ä»¥æŸ¥çœ‹
- âœ… æ”¯æŒæŒ‰æ–‡ä»¶å¤¹è¿‡æ»¤
- âœ… æ—¥å¿—ä¿¡æ¯å®Œæ•´å‡†ç¡®

---

### ğŸ“Š Phase 7 äº¤ä»˜ç‰©æ£€æŸ¥æ¸…å•

- [ ] ä¸»ç•Œé¢å®Œå–„å®Œæˆ
- [ ] åŒæ­¥è¿›åº¦æ˜¾ç¤ºå®ç°
- [ ] åŒæ­¥æ—¥å¿—åŠŸèƒ½å®Œæˆ
- [ ] ç”¨æˆ·ä½“éªŒä¼˜åŒ–å®Œæˆ

---

## ğŸ“… Phase 8: æ€§èƒ½ä¼˜åŒ–ä¸æµ‹è¯• (Week 8)

### ğŸ¯ é˜¶æ®µç›®æ ‡
- å®ç°å¢é‡åŒæ­¥ç®—æ³•
- ä¼˜åŒ–å†…å­˜ä½¿ç”¨
- ä¼˜åŒ–åŒæ­¥æ€§èƒ½
- å®Œæˆæ€§èƒ½æµ‹è¯•

### ğŸ“ è¯¦ç»†ä»»åŠ¡æ¸…å•

#### Task 8.1: å¢é‡åŒæ­¥å®ç° (Day 1-3)

**ç›®æ ‡**: å®ç°åŸºäºå“ˆå¸Œçš„å¢é‡åŒæ­¥

**å®æ–½æ­¥éª¤**:

1. **å®ç°æ–‡ä»¶å“ˆå¸Œè®¡ç®—**
   ```rust
   use sha2::{Sha256, Digest};
   
   pub fn calculate_file_hash(path: &Path) -> Result<String> {
       let file_size = std::fs::metadata(path)?.len();
       
       if file_size < 1_000_000 {
           // å°æ–‡ä»¶ï¼šå®Œæ•´å“ˆå¸Œ
           let mut hasher = Sha256::new();
           let content = std::fs::read(path)?;
           hasher.update(&content);
           Ok(format!("{:x}", hasher.finalize()))
       } else if file_size < 50_000_000 {
           // ä¸­ç­‰æ–‡ä»¶ï¼šåˆ†å—å“ˆå¸Œ
           let chunk_size = 1_000_000;
           let mut hasher = Sha256::new();
           let mut file = std::fs::File::open(path)?;
           let mut buffer = vec![0u8; chunk_size];
           
           loop {
               let bytes_read = file.read(&mut buffer)?;
               if bytes_read == 0 {
                   break;
               }
               hasher.update(&buffer[..bytes_read]);
           }
           
           Ok(format!("{:x}", hasher.finalize()))
       } else {
           // å¤§æ–‡ä»¶ï¼šä»…ä½¿ç”¨ä¿®æ”¹æ—¶é—´å’Œå¤§å°
           let metadata = std::fs::metadata(path)?;
           let modified = metadata.modified()?.duration_since(UNIX_EPOCH)?.as_secs();
           Ok(format!("{}_{}", modified, file_size))
       }
   }
   ```

2. **å®ç°å¢é‡ä¸Šä¼ **
   ```rust
   pub async fn incremental_upload(
       client: &WebDavClient,
       local_path: &Path,
       remote_path: &str,
   ) -> Result<()> {
       // æ£€æŸ¥è¿œç¨‹æ–‡ä»¶æ˜¯å¦å­˜åœ¨
       if let Some(remote_meta) = client.get_metadata(remote_path).await? {
           let local_hash = calculate_file_hash(local_path)?;
           
           if local_hash == remote_meta.content_hash {
               // æ–‡ä»¶ç›¸åŒï¼Œè·³è¿‡
               return Ok(());
           }
       }
       
       // ä¸Šä¼ æ–‡ä»¶
       client.upload(local_path, remote_path).await?;
       Ok(())
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- âœ… å°æ–‡ä»¶ä½¿ç”¨å®Œæ•´å“ˆå¸Œ
- âœ… ä¸­ç­‰æ–‡ä»¶ä½¿ç”¨åˆ†å—å“ˆå¸Œ
- âœ… å¤§æ–‡ä»¶ä½¿ç”¨å…ƒæ•°æ®æ¯”è¾ƒ
- âœ… å¢é‡åŒæ­¥å‡å°‘ä¼ è¾“é‡

**å‚è€ƒæ–‡æ¡£**: `é¡¹ç›®éœ€æ±‚åˆ†æ.md` 3.2.1 - å¢é‡åŒæ­¥ç®—æ³•

---

#### Task 8.2: å†…å­˜ä¼˜åŒ– (Day 3-5)

**ç›®æ ‡**: ä¼˜åŒ–å†…å­˜ä½¿ç”¨ï¼Œç¡®ä¿ < 50MB

**å®æ–½æ­¥éª¤**:

1. **å®ç°æµå¼ä¼ è¾“**
   ```rust
   use tokio::io::{AsyncReadExt, AsyncWriteExt};
   
   pub async fn stream_upload(
       client: &WebDavClient,
       local_path: &Path,
       remote_path: &str,
   ) -> Result<()> {
       let mut file = tokio::fs::File::open(local_path).await?;
       let mut buffer = vec![0u8; 8192]; // 8KB ç¼“å†²åŒº
       
       let mut uploader = client.start_upload(remote_path).await?;
       
       loop {
           let bytes_read = file.read(&mut buffer).await?;
           if bytes_read == 0 {
               break;
           }
           uploader.write_all(&buffer[..bytes_read]).await?;
       }
       
       uploader.finish().await?;
       Ok(())
   }
   ```

2. **ä¼˜åŒ–æ–‡ä»¶åˆ—è¡¨å†…å­˜**
   ```rust
   // ä½¿ç”¨è¿­ä»£å™¨è€Œä¸æ˜¯Vecå­˜å‚¨æ‰€æœ‰æ–‡ä»¶
   pub fn scan_directory_iter(path: &Path) -> impl Iterator<Item = FileMetadata> {
       WalkDir::new(path)
           .into_iter()
           .filter_map(|entry| entry.ok())
           .map(|entry| {
               // å¤„ç†æ–‡ä»¶å…ƒæ•°æ®
           })
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- âœ… å†…å­˜å ç”¨ < 50MBï¼ˆç©ºé—²ï¼‰
- âœ… å†…å­˜å ç”¨ < 80MBï¼ˆåŒæ­¥ä¸­ï¼‰
- âœ… å¤§æ–‡ä»¶ä¼ è¾“ä¸å ç”¨è¿‡å¤šå†…å­˜

**å‚è€ƒæ–‡æ¡£**: `å¯ç”¨å­¦ä¹ å†…å®¹.md` ç¬¬16èŠ‚ - æ€§èƒ½ä¼˜åŒ–æŠ€å·§

---

#### Task 8.3: æ€§èƒ½æµ‹è¯• (Day 5-7)

**ç›®æ ‡**: å®Œæˆæ€§èƒ½åŸºå‡†æµ‹è¯•

**å®æ–½æ­¥éª¤**:

1. **åˆ›å»ºæ€§èƒ½æµ‹è¯•ç”¨ä¾‹**
   ```rust
   #[cfg(test)]
   mod tests {
       use super::*;
       
       #[tokio::test]
       async fn test_file_scan_performance() {
           let start = Instant::now();
           let snapshot = scan_local_directory(Path::new("/test")).unwrap();
           let duration = start.elapsed();
           
           assert!(duration.as_secs() < 2, "æ–‡ä»¶æ‰«æåº”åœ¨2ç§’å†…å®Œæˆ");
           assert!(snapshot.files.len() > 1000, "åº”æ‰«æè¶…è¿‡1000ä¸ªæ–‡ä»¶");
       }
       
       #[tokio::test]
       async fn test_memory_usage() {
           // æµ‹è¯•å†…å­˜ä½¿ç”¨
       }
   }
   ```

2. **æ€§èƒ½åŸºå‡†æŠ¥å‘Š**
   - æ–‡ä»¶æ‰«æé€Ÿåº¦: > 1000ä¸ª/ç§’
   - å†…å­˜å ç”¨: < 50MB
   - CPUä½¿ç”¨: ç©ºé—² < 1%, åŒæ­¥ < 10%
   - å¯åŠ¨æ—¶é—´: < 3ç§’

**éªŒæ”¶æ ‡å‡†**:
- âœ… æ‰€æœ‰æ€§èƒ½æŒ‡æ ‡è¾¾æ ‡
- âœ… æ€§èƒ½æµ‹è¯•æŠ¥å‘Šå®Œæ•´
- âœ… æ€§èƒ½ä¼˜åŒ–æ•ˆæœæ˜æ˜¾

**å‚è€ƒæ–‡æ¡£**: `é¡¹ç›®éœ€æ±‚åˆ†æ.md` 4.1 - æ€§èƒ½éœ€æ±‚

---

### ğŸ“Š Phase 8 äº¤ä»˜ç‰©æ£€æŸ¥æ¸…å•

- [ ] å¢é‡åŒæ­¥ç®—æ³•å®ç°
- [ ] å†…å­˜ä¼˜åŒ–å®Œæˆ
- [ ] æ€§èƒ½æµ‹è¯•å®Œæˆ
- [ ] æ‰€æœ‰æ€§èƒ½æŒ‡æ ‡è¾¾æ ‡

---

## ğŸ“… Phase 9: é”™è¯¯å¤„ç†ä¸ç¨³å®šæ€§ (Week 9)

### ğŸ¯ é˜¶æ®µç›®æ ‡
- å®Œå–„é”™è¯¯å¤„ç†æœºåˆ¶
- å®ç°é‡è¯•ç­–ç•¥
- å®ç°æ•°æ®æ¢å¤åŠŸèƒ½
- å®Œæˆç¨³å®šæ€§æµ‹è¯•

### ğŸ“ è¯¦ç»†ä»»åŠ¡æ¸…å•

#### Task 9.1: é‡è¯•æœºåˆ¶å®ç° (Day 1-3)

**ç›®æ ‡**: å®ç°æŒ‡æ•°é€€é¿é‡è¯•ç­–ç•¥

**å®æ–½æ­¥éª¤**:

1. **å®ç°é‡è¯•ç­–ç•¥**
   ```rust
   pub struct ExponentialBackoff {
       base_delay: Duration,
       max_delay: Duration,
       max_attempts: u32,
       multiplier: f64,
   }
   
   impl ExponentialBackoff {
       pub fn new() -> Self {
           Self {
               base_delay: Duration::from_secs(1),
               max_delay: Duration::from_secs(60),
               max_attempts: 3,
               multiplier: 2.0,
           }
       }
       
       pub fn next_delay(&self, attempt: u32) -> Option<Duration> {
           if attempt >= self.max_attempts {
               return None;
           }
           
           let delay = self.base_delay.mul_f64(self.multiplier.powi(attempt as i32));
           Some(delay.min(self.max_delay))
       }
   }
   
   pub async fn retry_with_backoff<F, T, E>(
       mut f: F,
       backoff: ExponentialBackoff,
   ) -> Result<T, E>
   where
       F: FnMut() -> Result<T, E>,
   {
       let mut attempt = 0;
       loop {
           match f() {
               Ok(result) => return Ok(result),
               Err(e) => {
                   if let Some(delay) = backoff.next_delay(attempt) {
                       tokio::time::sleep(delay).await;
                       attempt += 1;
                   } else {
                       return Err(e);
                   }
               }
           }
       }
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- âœ… ç½‘ç»œé”™è¯¯è‡ªåŠ¨é‡è¯•
- âœ… é‡è¯•é—´éš”æŒ‡æ•°å¢é•¿
- âœ… è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°åæ”¾å¼ƒ

**å‚è€ƒæ–‡æ¡£**: `é¡¹ç›®éœ€æ±‚åˆ†æ.md` 4.2.1 - é”™è¯¯å¤„ç†ç­–ç•¥

---

#### Task 9.2: æ•°æ®ä¸€è‡´æ€§ä¿éšœ (Day 3-5)

**ç›®æ ‡**: ç¡®ä¿åŒæ­¥è¿‡ç¨‹ä¸­æ•°æ®ä¸€è‡´æ€§

**å®æ–½æ­¥éª¤**:

1. **å®ç°äº‹åŠ¡æœºåˆ¶**
   ```rust
   pub struct SyncTransaction {
       operations: Vec<SyncOperation>,
       rollback_operations: Vec<SyncOperation>,
   }
   
   impl SyncTransaction {
       pub async fn commit(&mut self) -> Result<()> {
           for op in &self.operations {
               match op.execute().await {
                   Ok(_) => {}
                   Err(e) => {
                       // å›æ»šå·²æ‰§è¡Œçš„æ“ä½œ
                       self.rollback().await?;
                       return Err(e);
                   }
               }
           }
           Ok(())
       }
       
       pub async fn rollback(&mut self) -> Result<()> {
           for op in self.rollback_operations.iter().rev() {
               op.undo().await?;
           }
           Ok(())
       }
   }
   ```

2. **å®ç°å¿«ç…§å¤‡ä»½**
   ```rust
   pub fn backup_snapshot(snapshot: &FileSnapshot) -> Result<()> {
       let backup_path = get_backup_path();
       let json = serde_json::to_string(snapshot)?;
       std::fs::write(backup_path, json)?;
       Ok(())
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- âœ… åŒæ­¥å¤±è´¥å¯ä»¥å›æ»š
- âœ… å¿«ç…§å®šæœŸå¤‡ä»½
- âœ… æ•°æ®ä¸€è‡´æ€§å¾—åˆ°ä¿éšœ

---

#### Task 9.3: ç¨³å®šæ€§æµ‹è¯• (Day 5-7)

**ç›®æ ‡**: å®Œæˆé•¿æ—¶é—´è¿è¡Œæµ‹è¯•

**å®æ–½æ­¥éª¤**:

1. **åˆ›å»ºç¨³å®šæ€§æµ‹è¯•**
   ```rust
   #[tokio::test]
   async fn test_long_running() {
       // è¿è¡Œ24å°æ—¶åŒæ­¥æµ‹è¯•
       // ç›‘æ§å†…å­˜æ³„æ¼
       // æ£€æŸ¥é”™è¯¯ç‡
   }
   ```

2. **é”™è¯¯ç‡ç»Ÿè®¡**
   - åŒæ­¥æˆåŠŸç‡ > 99%
   - æ— å†…å­˜æ³„æ¼
   - æ— å´©æºƒ

**éªŒæ”¶æ ‡å‡†**:
- âœ… 7Ã—24å°æ—¶è¿è¡Œæ— å´©æºƒ
- âœ… å†…å­˜ä½¿ç”¨ç¨³å®š
- âœ… é”™è¯¯ç‡ < 1%

**å‚è€ƒæ–‡æ¡£**: `é¡¹ç›®éœ€æ±‚åˆ†æ.md` 8.2.1 - å¯é æ€§éªŒæ”¶

---

### ğŸ“Š Phase 9 äº¤ä»˜ç‰©æ£€æŸ¥æ¸…å•

- [ ] é‡è¯•æœºåˆ¶å®ç°
- [ ] æ•°æ®ä¸€è‡´æ€§ä¿éšœå®Œæˆ
- [ ] ç¨³å®šæ€§æµ‹è¯•é€šè¿‡
- [ ] é”™è¯¯å¤„ç†å®Œå–„

---

## ğŸ“… Phase 10: æ„å»ºä¸å‘å¸ƒ (Week 10)

### ğŸ¯ é˜¶æ®µç›®æ ‡
- é…ç½®æ„å»ºç³»ç»Ÿ
- å®ç°è‡ªåŠ¨æ›´æ–°
- å®Œæˆå¤šå¹³å°æ‰“åŒ…
- å‡†å¤‡å‘å¸ƒæ–‡æ¡£

### ğŸ“ è¯¦ç»†ä»»åŠ¡æ¸…å•

#### Task 10.1: æ„å»ºé…ç½®ä¼˜åŒ– (Day 1-2)

**ç›®æ ‡**: ä¼˜åŒ–ç”Ÿäº§æ„å»ºé…ç½®

**å®æ–½æ­¥éª¤**:

1. **é…ç½® Release æ„å»º**
   ```toml
   [profile.release]
   opt-level = 3
   lto = true
   codegen-units = 1
   strip = true
   ```

2. **é…ç½® Vite æ„å»º**
   ```javascript
   build: {
       target: process.env.TAURI_PLATFORM == 'windows' 
           ? 'chrome105' 
           : 'safari11',
       minify: !process.env.TAURI_DEBUG ? 'esbuild' : false,
       sourcemap: !!process.env.TAURI_DEBUG,
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- âœ… æ„å»ºäº§ç‰©å¤§å°åˆç†
- âœ… æ„å»ºé€Ÿåº¦å¯æ¥å—
- âœ… ç”Ÿäº§ç‰ˆæœ¬æ€§èƒ½è‰¯å¥½

**å‚è€ƒæ–‡æ¡£**: `å¯ç”¨å­¦ä¹ å†…å®¹.md` ç¬¬13èŠ‚ - æ„å»ºä¸æ‰“åŒ…

---

#### Task 10.2: è‡ªåŠ¨æ›´æ–°åŠŸèƒ½ (Day 2-4)

**ç›®æ ‡**: å®ç°åº”ç”¨è‡ªåŠ¨æ›´æ–°

**å®æ–½æ­¥éª¤**:

1. **é…ç½®æ›´æ–°æœåŠ¡**
   ```json
   {
       "updater": {
           "active": true,
           "dialog": true,
           "endpoints": [
               "https://github.com/your-org/lightsync/releases/download/updater/update.json"
           ],
           "pubkey": "your-public-key"
       }
   }
   ```

2. **å®ç°æ›´æ–°æ£€æŸ¥**
   ```rust
   pub fn check_update(app_handle: tauri::AppHandle) {
       tauri::async_runtime::spawn(async move {
           match tauri::updater::builder(app_handle).check().await {
               Ok(update) => {
                   if update.is_update_available() {
                       // æ˜¾ç¤ºæ›´æ–°å¯¹è¯æ¡†
                   }
               }
               Err(e) => {
                   warn!("Failed to check update: {}", e);
               }
           }
       });
   }
   ```

**éªŒæ”¶æ ‡å‡†**:
- âœ… å¯ä»¥æ£€æµ‹æ›´æ–°
- âœ… æ›´æ–°å¯¹è¯æ¡†æ­£å¸¸æ˜¾ç¤º
- âœ… æ›´æ–°å®‰è£…æµç¨‹æ­£å¸¸

**å‚è€ƒæ–‡æ¡£**: `å¯ç”¨å­¦ä¹ å†…å®¹.md` ç¬¬11èŠ‚ - æ›´æ–°æœºåˆ¶

---

#### Task 10.3: å¤šå¹³å°æ‰“åŒ… (Day 4-6)

**ç›®æ ‡**: å®Œæˆ Windowsã€macOSã€Linux æ‰“åŒ…

**å®æ–½æ­¥éª¤**:

1. **é…ç½®æ‰“åŒ…é€‰é¡¹**
   ```json
   {
       "bundle": {
           "targets": ["msi", "nsis", "app", "dmg", "appimage"],
           "identifier": "com.lightsync.app"
       }
   }
   ```

2. **åˆ›å»º CI/CD æµç¨‹**
   ```yaml
   # .github/workflows/build.yml
   name: Build
   on: [push, pull_request]
   jobs:
     build:
       strategy:
         matrix:
           platform: [macos-latest, ubuntu-latest, windows-latest]
       runs-on: ${{ matrix.platform }}
       steps:
         - uses: actions/checkout@v3
         - uses: actions/setup-node@v3
         - uses: dtolnay/rust-toolchain@stable
         - run: npm install
         - run: npm run tauri build
   ```

**éªŒæ”¶æ ‡å‡†**:
- âœ… Windows MSI/NSIS åŒ…å¯ä»¥æ„å»º
- âœ… macOS DMG åŒ…å¯ä»¥æ„å»º
- âœ… Linux AppImage åŒ…å¯ä»¥æ„å»º

**å‚è€ƒæ–‡æ¡£**: `å¯ç”¨å­¦ä¹ å†…å®¹.md` ç¬¬13èŠ‚ - æ„å»ºä¸æ‰“åŒ…

---

#### Task 10.4: æ–‡æ¡£å‡†å¤‡ (Day 6-7)

**ç›®æ ‡**: å‡†å¤‡ç”¨æˆ·æ–‡æ¡£å’Œå¼€å‘æ–‡æ¡£

**å®æ–½æ­¥éª¤**:

1. **ç”¨æˆ·ä½¿ç”¨æ‰‹å†Œ**
   - å®‰è£…æŒ‡å—
   - é…ç½®è¯´æ˜
   - å¸¸è§é—®é¢˜

2. **å¼€å‘æ–‡æ¡£**
   - æ¶æ„è¯´æ˜
   - API æ–‡æ¡£
   - è´¡çŒ®æŒ‡å—

**éªŒæ”¶æ ‡å‡†**:
- âœ… ç”¨æˆ·æ–‡æ¡£å®Œæ•´
- âœ… å¼€å‘æ–‡æ¡£æ¸…æ™°
- âœ… ç¤ºä¾‹ä»£ç å¯ç”¨

---

### ğŸ“Š Phase 10 äº¤ä»˜ç‰©æ£€æŸ¥æ¸…å•

- [ ] æ„å»ºé…ç½®ä¼˜åŒ–å®Œæˆ
- [ ] è‡ªåŠ¨æ›´æ–°åŠŸèƒ½å®ç°
- [ ] å¤šå¹³å°æ‰“åŒ…å®Œæˆ
- [ ] æ–‡æ¡£å‡†å¤‡å®Œæˆ

---

## ğŸ“Š æ€»ä½“è¿›åº¦è·Ÿè¸ª

### é‡Œç¨‹ç¢‘æ£€æŸ¥ç‚¹

| é˜¶æ®µ | æ—¶é—´ | å…³é”®äº¤ä»˜ç‰© | éªŒæ”¶æ ‡å‡† |
| ---- | ---- | ---------- | --------- |
| **Phase 1** | Week 1 | é¡¹ç›®æ¡†æ¶ã€é…ç½®ç³»ç»Ÿ | åº”ç”¨å¯å¯åŠ¨ï¼Œé…ç½®å¯ä¿å­˜ |
| **Phase 2** | Week 2 | WebDAVè¿æ¥ã€è®¤è¯ | å¯ä»¥è¿æ¥æµ‹è¯•æœåŠ¡å™¨ |
| **Phase 3** | Week 3 | æ–‡ä»¶ç›‘æ§ | æ–‡ä»¶å˜æ›´å¯ä»¥æ£€æµ‹ |
| **Phase 4** | Week 4 | åŒæ­¥å¼•æ“ | å¯ä»¥æ‰§è¡ŒåŒå‘åŒæ­¥ |
| **Phase 5** | Week 5 | æ–‡ä»¶å¤¹é…ç½® | å¯ä»¥é…ç½®åŒæ­¥æ–‡ä»¶å¤¹ |
| **Phase 6** | Week 6 | å®šæ—¶ä»»åŠ¡ã€æ‰˜ç›˜ | åå°è‡ªåŠ¨åŒæ­¥å·¥ä½œ |
| **Phase 7** | Week 7 | UIå®Œå–„ | ç•Œé¢å®Œæ•´ï¼Œä½“éªŒè‰¯å¥½ |
| **Phase 8** | Week 8 | æ€§èƒ½ä¼˜åŒ– | æ€§èƒ½æŒ‡æ ‡è¾¾æ ‡ |
| **Phase 9** | Week 9 | ç¨³å®šæ€§ | é•¿æ—¶é—´è¿è¡Œç¨³å®š |
| **Phase 10** | Week 10 | æ„å»ºå‘å¸ƒ | å¯ä»¥æ‰“åŒ…å‘å¸ƒ |

---

## ğŸ¯ å…³é”®æˆåŠŸå› ç´ 

### æŠ€æœ¯å±‚é¢
1. **éµå¾ªæœ€ä½³å®è·µ**: å‚è€ƒ pot-desktop çš„å®ç°æ¨¡å¼
2. **é”™è¯¯å¤„ç†å®Œå–„**: ä½¿ç”¨ thiserror ç»Ÿä¸€é”™è¯¯å¤„ç†
3. **æ€§èƒ½ä¼˜åŒ–**: å¢é‡åŒæ­¥ã€æµå¼ä¼ è¾“ã€å†…å­˜ä¼˜åŒ–
4. **å®‰å…¨æ€§**: å¯†ç ä½¿ç”¨å¯†é’¥ç¯ï¼Œæœ€å°æƒé™åŸåˆ™

### é¡¹ç›®ç®¡ç†
1. **æ¸è¿›å¼å¼€å‘**: æ¯ä¸ªé˜¶æ®µéƒ½æœ‰å¯äº¤ä»˜æˆæœ
2. **æŒç»­æµ‹è¯•**: æ¯ä¸ªé˜¶æ®µéƒ½è¿›è¡Œæµ‹è¯•éªŒè¯
3. **æ–‡æ¡£åŒæ­¥**: ä»£ç å’Œæ–‡æ¡£åŒæ­¥æ›´æ–°
4. **ä»£ç å®¡æŸ¥**: å…³é”®ä»£ç è¿›è¡Œå®¡æŸ¥

---

## ğŸ“š å‚è€ƒèµ„æº

### æŠ€æœ¯æ–‡æ¡£
- Tauri å®˜æ–¹æ–‡æ¡£: https://tauri.app/v1/guides/
- Rust Book: https://doc.rust-lang.org/book/
- WebDAV RFC 4918: https://tools.ietf.org/html/rfc4918

### å­¦ä¹ èµ„æº
- `å¯ç”¨å­¦ä¹ å†…å®¹ï¼ˆå¯¹åº”pot-desktopï¼‰.md` - æŠ€æœ¯å®ç°å‚è€ƒ
- `é¡¹ç›®éœ€æ±‚åˆ†æ.md` - åŠŸèƒ½éœ€æ±‚å‚è€ƒ

---

## âœ… æœ€ç»ˆéªŒæ”¶æ ‡å‡†

### åŠŸèƒ½éªŒæ”¶
- [ ] æ”¯æŒé…ç½®å¤šä¸ª WebDAV æœåŠ¡å™¨
- [ ] æ”¯æŒé…ç½®å¤šä¸ªåŒæ­¥æ–‡ä»¶å¤¹
- [ ] æ”¯æŒåŒå‘åŒæ­¥ã€ä»…ä¸Šä¼ ã€ä»…ä¸‹è½½
- [ ] æ”¯æŒå®æ—¶ç›‘æ§ã€å®šæ—¶åŒæ­¥ã€æ‰‹åŠ¨åŒæ­¥
- [ ] æ”¯æŒå†²çªæ£€æµ‹å’Œè§£å†³
- [ ] æ”¯æŒç³»ç»Ÿæ‰˜ç›˜å’Œåå°è¿è¡Œ

### æ€§èƒ½éªŒæ”¶
- [ ] å†…å­˜å ç”¨ < 50MBï¼ˆç©ºé—²ï¼‰
- [ ] å¯åŠ¨æ—¶é—´ < 3ç§’
- [ ] æ–‡ä»¶æ‰«æé€Ÿåº¦ > 1000ä¸ª/ç§’
- [ ] CPUä½¿ç”¨ < 10%ï¼ˆåŒæ­¥ä¸­ï¼‰

### è´¨é‡éªŒæ”¶
- [ ] åŒæ­¥æˆåŠŸç‡ > 99%
- [ ] 7Ã—24å°æ—¶è¿è¡Œæ— å´©æºƒ
- [ ] æ”¯æŒ Windowsã€macOSã€Linux
- [ ] ç”¨æˆ·æ–‡æ¡£å®Œæ•´

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0  
**æœ€åæ›´æ–°**: 2024  
**ç»´æŠ¤è€…**: LightSync å¼€å‘å›¢é˜Ÿ

